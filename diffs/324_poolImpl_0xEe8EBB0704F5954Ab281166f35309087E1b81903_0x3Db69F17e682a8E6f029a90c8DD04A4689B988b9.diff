diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/BorrowLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/BorrowLogic.sol
index e7efddd..1b1a18b 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/BorrowLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/BorrowLogic.sol
@@ -4,12 +4,10 @@ pragma solidity ^0.8.10;
 import {GPv2SafeERC20} from "../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
 import {SafeCast} from "../../../dependencies/openzeppelin/contracts/SafeCast.sol";
 import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
-import {IStableDebtToken} from "../../../interfaces/IStableDebtToken.sol";
 import {IVariableDebtToken} from "../../../interfaces/IVariableDebtToken.sol";
 import {IAToken} from "../../../interfaces/IAToken.sol";
 import {UserConfiguration} from "../configuration/UserConfiguration.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
-import {Helpers} from "../helpers/Helpers.sol";
 import {DataTypes} from "../types/DataTypes.sol";
 import {ValidationLogic} from "./ValidationLogic.sol";
 import {ReserveLogic} from "./ReserveLogic.sol";
@@ -45,15 +43,6 @@ library BorrowLogic {
         uint256 amount,
         bool useATokens
     );
-    event RebalanceStableBorrowRate(
-        address indexed reserve,
-        address indexed user
-    );
-    event SwapBorrowRateMode(
-        address indexed reserve,
-        address indexed user,
-        DataTypes.InterestRateMode interestRateMode
-    );
     event IsolationModeTotalDebtUpdated(
         address indexed asset,
         uint256 totalDebt
@@ -103,7 +92,6 @@ library BorrowLogic {
                 userAddress: params.onBehalfOf,
                 amount: params.amount,
                 interestRateMode: params.interestRateMode,
-                maxStableLoanPercent: params.maxStableRateBorrowSizePercent,
                 reservesCount: params.reservesCount,
                 oracle: params.oracle,
                 userEModeCategory: params.userEModeCategory,
@@ -114,33 +102,17 @@ library BorrowLogic {
             })
         );
 
-        uint256 currentStableRate = 0;
         bool isFirstBorrowing = false;
 
-        if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {
-            currentStableRate = reserve.currentStableBorrowRate;
-
-            (
-                isFirstBorrowing,
-                reserveCache.nextTotalStableDebt,
-                reserveCache.nextAvgStableBorrowRate
-            ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(
-                params.user,
-                params.onBehalfOf,
-                params.amount,
-                currentStableRate
-            );
-        } else {
-            (
-                isFirstBorrowing,
-                reserveCache.nextScaledVariableDebt
-            ) = IVariableDebtToken(reserveCache.variableDebtTokenAddress).mint(
-                params.user,
-                params.onBehalfOf,
-                params.amount,
-                reserveCache.nextVariableBorrowIndex
-            );
-        }
+        (
+            isFirstBorrowing,
+            reserveCache.nextScaledVariableDebt
+        ) = IVariableDebtToken(reserveCache.variableDebtTokenAddress).mint(
+            params.user,
+            params.onBehalfOf,
+            params.amount,
+            reserveCache.nextVariableBorrowIndex
+        );
 
         if (isFirstBorrowing) {
             userConfig.setBorrowing(reserve.id, true);
@@ -179,10 +151,8 @@ library BorrowLogic {
             params.user,
             params.onBehalfOf,
             params.amount,
-            params.interestRateMode,
-            params.interestRateMode == DataTypes.InterestRateMode.STABLE
-                ? currentStableRate
-                : reserve.currentVariableBorrowRate,
+            DataTypes.InterestRateMode.VARIABLE,
+            reserve.currentVariableBorrowRate,
             params.referralCode
         );
     }
@@ -208,24 +178,18 @@ library BorrowLogic {
         DataTypes.ReserveCache memory reserveCache = reserve.cache();
         reserve.updateState(reserveCache);
 
-        (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(
-            params.onBehalfOf,
-            reserveCache
-        );
+        uint256 variableDebt = IERC20(reserveCache.variableDebtTokenAddress)
+            .balanceOf(params.onBehalfOf);
 
         ValidationLogic.validateRepay(
             reserveCache,
             params.amount,
             params.interestRateMode,
             params.onBehalfOf,
-            stableDebt,
             variableDebt
         );
 
-        uint256 paybackAmount = params.interestRateMode ==
-            DataTypes.InterestRateMode.STABLE
-            ? stableDebt
-            : variableDebt;
+        uint256 paybackAmount = variableDebt;
 
         // Allows a user to repay with aTokens without leaving dust from interest.
         if (params.useATokens && params.amount == type(uint256).max) {
@@ -238,23 +202,13 @@ library BorrowLogic {
             paybackAmount = params.amount;
         }
 
-        if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {
-            (
-                reserveCache.nextTotalStableDebt,
-                reserveCache.nextAvgStableBorrowRate
-            ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).burn(
+        reserveCache.nextScaledVariableDebt = IVariableDebtToken(
+            reserveCache.variableDebtTokenAddress
+        ).burn(
                 params.onBehalfOf,
-                paybackAmount
+                paybackAmount,
+                reserveCache.nextVariableBorrowIndex
             );
-        } else {
-            reserveCache.nextScaledVariableDebt = IVariableDebtToken(
-                reserveCache.variableDebtTokenAddress
-            ).burn(
-                    params.onBehalfOf,
-                    paybackAmount,
-                    reserveCache.nextVariableBorrowIndex
-                );
-        }
 
         reserve.updateInterestRatesAndVirtualBalance(
             reserveCache,
@@ -263,7 +217,7 @@ library BorrowLogic {
             0
         );
 
-        if (stableDebt + variableDebt - paybackAmount == 0) {
+        if (variableDebt - paybackAmount == 0) {
             userConfig.setBorrowing(reserve.id, false);
         }
 
@@ -314,123 +268,4 @@ library BorrowLogic {
 
         return paybackAmount;
     }
-
-    /**
-     * @notice Implements the rebalance stable borrow rate feature. In case of liquidity crunches on the protocol, stable
-     * rate borrows might need to be rebalanced to bring back equilibrium between the borrow and supply APYs.
-     * @dev The rules that define if a position can be rebalanced are implemented in `ValidationLogic.validateRebalanceStableBorrowRate()`
-     * @dev Emits the `RebalanceStableBorrowRate()` event
-     * @param reserve The state of the reserve of the asset being repaid
-     * @param asset The asset of the position being rebalanced
-     * @param user The user being rebalanced
-     */
-    function executeRebalanceStableBorrowRate(
-        DataTypes.ReserveData storage reserve,
-        address asset,
-        address user
-    ) external {
-        DataTypes.ReserveCache memory reserveCache = reserve.cache();
-        reserve.updateState(reserveCache);
-
-        ValidationLogic.validateRebalanceStableBorrowRate(
-            reserve,
-            reserveCache,
-            asset
-        );
-
-        IStableDebtToken stableDebtToken = IStableDebtToken(
-            reserveCache.stableDebtTokenAddress
-        );
-        uint256 stableDebt = IERC20(address(stableDebtToken)).balanceOf(user);
-
-        stableDebtToken.burn(user, stableDebt);
-
-        (
-            ,
-            reserveCache.nextTotalStableDebt,
-            reserveCache.nextAvgStableBorrowRate
-        ) = stableDebtToken.mint(
-            user,
-            user,
-            stableDebt,
-            reserve.currentStableBorrowRate
-        );
-
-        reserve.updateInterestRatesAndVirtualBalance(reserveCache, asset, 0, 0);
-
-        emit RebalanceStableBorrowRate(asset, user);
-    }
-
-    /**
-     * @notice Implements the swap borrow rate feature. Borrowers can swap from variable to stable positions at any time.
-     * @dev Emits the `Swap()` event
-     * @param reserve The of the reserve of the asset being repaid
-     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets
-     * @param asset The asset of the position being swapped
-     * @param user The user whose debt position is being swapped
-     * @param interestRateMode The current interest rate mode of the position being swapped
-     */
-    function executeSwapBorrowRateMode(
-        DataTypes.ReserveData storage reserve,
-        DataTypes.UserConfigurationMap storage userConfig,
-        address asset,
-        address user,
-        DataTypes.InterestRateMode interestRateMode
-    ) external {
-        DataTypes.ReserveCache memory reserveCache = reserve.cache();
-
-        reserve.updateState(reserveCache);
-
-        (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(
-            user,
-            reserveCache
-        );
-
-        ValidationLogic.validateSwapRateMode(
-            reserve,
-            reserveCache,
-            userConfig,
-            stableDebt,
-            variableDebt,
-            interestRateMode
-        );
-
-        if (interestRateMode == DataTypes.InterestRateMode.STABLE) {
-            (
-                reserveCache.nextTotalStableDebt,
-                reserveCache.nextAvgStableBorrowRate
-            ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).burn(
-                user,
-                stableDebt
-            );
-
-            (, reserveCache.nextScaledVariableDebt) = IVariableDebtToken(
-                reserveCache.variableDebtTokenAddress
-            ).mint(
-                    user,
-                    user,
-                    stableDebt,
-                    reserveCache.nextVariableBorrowIndex
-                );
-        } else {
-            reserveCache.nextScaledVariableDebt = IVariableDebtToken(
-                reserveCache.variableDebtTokenAddress
-            ).burn(user, variableDebt, reserveCache.nextVariableBorrowIndex);
-
-            (
-                ,
-                reserveCache.nextTotalStableDebt,
-                reserveCache.nextAvgStableBorrowRate
-            ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(
-                user,
-                user,
-                variableDebt,
-                reserve.currentStableBorrowRate
-            );
-        }
-
-        reserve.updateInterestRatesAndVirtualBalance(reserveCache, asset, 0, 0);
-
-        emit SwapBorrowRateMode(asset, user, interestRateMode);
-    }
 }
diff --git a/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/CustomInitialize.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/CustomInitialize.sol
new file mode 100644
index 0000000..8b16d14
--- /dev/null
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/CustomInitialize.sol
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {DataTypes} from "aave-v3-origin/contracts/protocol/pool/Pool.sol";
+import {IERC20} from "aave-v3-origin/contracts/dependencies/openzeppelin/contracts/IERC20.sol";
+import {SafeCast} from "aave-v3-origin/contracts/dependencies/openzeppelin/contracts/SafeCast.sol";
+import {WadRayMath} from "aave-v3-origin/contracts/protocol/libraries/math/WadRayMath.sol";
+import {MathUtils} from "aave-v3-origin/contracts/protocol/libraries/math/MathUtils.sol";
+import {ReserveConfiguration} from "aave-v3-origin/contracts/protocol/libraries/configuration/ReserveConfiguration.sol";
+import {ReserveLogic} from "aave-v3-origin/contracts/protocol/libraries/logic/ReserveLogic.sol";
+
+library CustomInitialize {
+    using ReserveLogic for DataTypes.ReserveCache;
+    using ReserveLogic for DataTypes.ReserveData;
+    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+
+    function initialize(
+        uint256 reservesCount,
+        mapping(uint256 => address) storage _reservesList,
+        mapping(address => DataTypes.ReserveData) storage _reserves
+    ) internal {
+        for (uint256 i = 0; i < reservesCount; i++) {
+            address currentReserveAddress = _reservesList[i];
+            DataTypes.ReserveData storage currentReserve = _reserves[
+                currentReserveAddress
+            ];
+            currentReserve.__deprecatedStableDebtTokenAddress = address(0);
+            require(currentReserve.__deprecatedStableBorrowRate == 0);
+        }
+    }
+}
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/DataTypes.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/DataTypes.sol
index 8112a41..3eb4af3 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/DataTypes.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/DataTypes.sol
@@ -17,7 +17,7 @@ library DataTypes {
         uint128 variableBorrowIndex;
         //the current variable borrow rate. Expressed in ray
         uint128 currentVariableBorrowRate;
-        //the current stable borrow rate. Expressed in ray
+        // DEPRECATED on v3.2.0
         uint128 currentStableBorrowRate;
         //timestamp of last update
         uint40 lastUpdateTimestamp;
@@ -25,7 +25,7 @@ library DataTypes {
         uint16 id;
         //aToken address
         address aTokenAddress;
-        //stableDebtToken address
+        // DEPRECATED on v3.2.0
         address stableDebtTokenAddress;
         //variableDebtToken address
         address variableDebtTokenAddress;
@@ -50,8 +50,8 @@ library DataTypes {
         uint128 variableBorrowIndex;
         //the current variable borrow rate. Expressed in ray
         uint128 currentVariableBorrowRate;
-        //the current stable borrow rate. Expressed in ray
-        uint128 currentStableBorrowRate;
+        // DEPRECATED on v3.2.0
+        uint128 __deprecatedStableBorrowRate;
         //timestamp of last update
         uint40 lastUpdateTimestamp;
         //the id of the reserve. Represents the position in the list of the active reserves
@@ -60,8 +60,8 @@ library DataTypes {
         uint40 liquidationGracePeriodUntil;
         //aToken address
         address aTokenAddress;
-        //stableDebtToken address
-        address stableDebtTokenAddress;
+        // DEPRECATED on v3.2.0
+        address __deprecatedStableDebtTokenAddress;
         //variableDebtToken address
         address variableDebtTokenAddress;
         //address of the interest rate strategy
@@ -84,7 +84,7 @@ library DataTypes {
         //bit 56: reserve is active
         //bit 57: reserve is frozen
         //bit 58: borrowing is enabled
-        //bit 59: stable rate borrowing enabled
+        //bit 59: DEPRECATED: stable rate borrowing enabled
         //bit 60: asset is paused
         //bit 61: borrowing in isolation mode is enabled
         //bit 62: siloed borrowing enabled
@@ -93,7 +93,7 @@ library DataTypes {
         //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap
         //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap
         //bit 152-167: liquidation protocol fee
-        //bit 168-175: eMode category
+        //bit 168-175: DEPRECATED: eMode category
         //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled
         //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals
         //bit 252: virtual accounting is enabled for the reserve
@@ -111,30 +111,49 @@ library DataTypes {
         uint256 data;
     }
 
-    struct EModeCategory {
+    // DEPRECATED: kept for backwards compatibility, might be removed in a future version
+    struct EModeCategoryLegacy {
         // each eMode category has a custom ltv and liquidation threshold
         uint16 ltv;
         uint16 liquidationThreshold;
         uint16 liquidationBonus;
-        // each eMode category may or may not have a custom oracle to override the individual assets price oracles
+        // DEPRECATED
         address priceSource;
         string label;
     }
 
+    struct CollateralConfig {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+    }
+
+    struct EModeCategoryBaseConfiguration {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        string label;
+    }
+
+    struct EModeCategory {
+        // each eMode category has a custom ltv and liquidation threshold
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        uint128 collateralBitmap;
+        string label;
+        uint128 borrowableBitmap;
+    }
+
     enum InterestRateMode {
         NONE,
-        STABLE,
+        __DEPRECATED,
         VARIABLE
     }
 
     struct ReserveCache {
         uint256 currScaledVariableDebt;
         uint256 nextScaledVariableDebt;
-        uint256 currPrincipalStableDebt;
-        uint256 currAvgStableBorrowRate;
-        uint256 currTotalStableDebt;
-        uint256 nextAvgStableBorrowRate;
-        uint256 nextTotalStableDebt;
         uint256 currLiquidityIndex;
         uint256 nextLiquidityIndex;
         uint256 currVariableBorrowIndex;
@@ -144,10 +163,8 @@ library DataTypes {
         uint256 reserveFactor;
         ReserveConfigurationMap reserveConfiguration;
         address aTokenAddress;
-        address stableDebtTokenAddress;
         address variableDebtTokenAddress;
         uint40 reserveLastUpdateTimestamp;
-        uint40 stableDebtLastUpdateTimestamp;
     }
 
     struct ExecuteLiquidationCallParams {
@@ -177,7 +194,6 @@ library DataTypes {
         InterestRateMode interestRateMode;
         uint16 referralCode;
         bool releaseUnderlying;
-        uint256 maxStableRateBorrowSizePercent;
         uint256 reservesCount;
         address oracle;
         uint8 userEModeCategory;
@@ -229,7 +245,6 @@ library DataTypes {
         uint16 referralCode;
         uint256 flashLoanPremiumToProtocol;
         uint256 flashLoanPremiumTotal;
-        uint256 maxStableRateBorrowSizePercent;
         uint256 reservesCount;
         address addressesProvider;
         address pool;
@@ -271,7 +286,6 @@ library DataTypes {
         address userAddress;
         uint256 amount;
         InterestRateMode interestRateMode;
-        uint256 maxStableLoanPercent;
         uint256 reservesCount;
         address oracle;
         uint8 userEModeCategory;
@@ -292,9 +306,7 @@ library DataTypes {
         uint256 unbacked;
         uint256 liquidityAdded;
         uint256 liquidityTaken;
-        uint256 totalStableDebt;
-        uint256 totalVariableDebt;
-        uint256 averageStableBorrowRate;
+        uint256 totalDebt;
         uint256 reserveFactor;
         address reserve;
         bool usingVirtualBalance;
@@ -304,7 +316,6 @@ library DataTypes {
     struct InitReserveParams {
         address asset;
         address aTokenAddress;
-        address stableDebtAddress;
         address variableDebtAddress;
         address interestRateStrategyAddress;
         uint16 reservesCount;
diff --git a/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/EModeConfiguration.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/EModeConfiguration.sol
new file mode 100644
index 0000000..2b0489a
--- /dev/null
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/EModeConfiguration.sol
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {Errors} from "../helpers/Errors.sol";
+import {DataTypes} from "../types/DataTypes.sol";
+import {ReserveConfiguration} from "./ReserveConfiguration.sol";
+
+/**
+ * @title EModeConfiguration library
+ * @author BGD Labs
+ * @notice Implements the bitmap logic to handle the eMode configuration
+ */
+library EModeConfiguration {
+    /**
+     * @notice Sets a bit in a given bitmap that represents the reserve index range
+     * @dev The supplied bitmap is supposed to be a uint128 in which each bit represents a reserve
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @param enabled True if the reserveIndex should be enabled on the bitmap, false otherwise
+     * @return The altered bitmap
+     */
+    function setReserveBitmapBit(
+        uint128 bitmap,
+        uint256 reserveIndex,
+        bool enabled
+    ) internal pure returns (uint128) {
+        unchecked {
+            require(
+                reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,
+                Errors.INVALID_RESERVE_INDEX
+            );
+            uint128 bit = uint128(1 << reserveIndex);
+            if (enabled) {
+                return bitmap | bit;
+            } else {
+                return bitmap & ~bit;
+            }
+        }
+    }
+
+    /**
+     * @notice Validates if a reserveIndex is flagged as enabled on a given bitmap
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @return True if the reserveindex is flagged true
+     */
+    function isReserveEnabledOnBitmap(
+        uint128 bitmap,
+        uint256 reserveIndex
+    ) internal pure returns (bool) {
+        unchecked {
+            require(
+                reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,
+                Errors.INVALID_RESERVE_INDEX
+            );
+            return (bitmap >> reserveIndex) & 1 != 0;
+        }
+    }
+}
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/EModeLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/EModeLogic.sol
index 3d098ba..4458909 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/EModeLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/EModeLogic.sol
@@ -46,67 +46,27 @@ library EModeLogic {
         DataTypes.UserConfigurationMap storage userConfig,
         DataTypes.ExecuteSetUserEModeParams memory params
     ) external {
+        if (usersEModeCategory[msg.sender] == params.categoryId) return;
+
         ValidationLogic.validateSetUserEMode(
-            reservesData,
-            reservesList,
             eModeCategories,
             userConfig,
             params.reservesCount,
             params.categoryId
         );
 
-        uint8 prevCategoryId = usersEModeCategory[msg.sender];
         usersEModeCategory[msg.sender] = params.categoryId;
 
-        if (prevCategoryId != 0) {
-            ValidationLogic.validateHealthFactor(
-                reservesData,
-                reservesList,
-                eModeCategories,
-                userConfig,
-                msg.sender,
-                params.categoryId,
-                params.reservesCount,
-                params.oracle
-            );
-        }
+        ValidationLogic.validateHealthFactor(
+            reservesData,
+            reservesList,
+            eModeCategories,
+            userConfig,
+            msg.sender,
+            params.categoryId,
+            params.reservesCount,
+            params.oracle
+        );
         emit UserEModeSet(msg.sender, params.categoryId);
     }
-
-    /**
-     * @notice Gets the eMode configuration and calculates the eMode asset price if a custom oracle is configured
-     * @dev The eMode asset price returned is 0 if no oracle is specified
-     * @param category The user eMode category
-     * @param oracle The price oracle
-     * @return The eMode ltv
-     * @return The eMode liquidation threshold
-     * @return The eMode asset price
-     */
-    function getEModeConfiguration(
-        DataTypes.EModeCategory storage category,
-        IPriceOracleGetter oracle
-    ) internal view returns (uint256, uint256, uint256) {
-        uint256 eModeAssetPrice = 0;
-        address eModePriceSource = category.priceSource;
-
-        if (eModePriceSource != address(0)) {
-            eModeAssetPrice = oracle.getAssetPrice(eModePriceSource);
-        }
-
-        return (category.ltv, category.liquidationThreshold, eModeAssetPrice);
-    }
-
-    /**
-     * @notice Checks if eMode is active for a user and if yes, if the asset belongs to the eMode category chosen
-     * @param eModeUserCategory The user eMode category
-     * @param eModeAssetCategory The asset eMode category
-     * @return True if eMode is active and the asset belongs to the eMode category chosen by the user, false otherwise
-     */
-    function isInEModeCategory(
-        uint256 eModeUserCategory,
-        uint256 eModeAssetCategory
-    ) internal pure returns (bool) {
-        return (eModeUserCategory != 0 &&
-            eModeAssetCategory == eModeUserCategory);
-    }
 }
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/Errors.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/Errors.sol
index 9da633f..d2a0c13 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/Errors.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/Errors.sol
@@ -37,7 +37,6 @@ library Errors {
     string public constant RESERVE_FROZEN = "28"; // 'Action cannot be performed because the reserve is frozen'
     string public constant RESERVE_PAUSED = "29"; // 'Action cannot be performed because the reserve is paused'
     string public constant BORROWING_NOT_ENABLED = "30"; // 'Borrowing is not enabled'
-    string public constant STABLE_BORROWING_NOT_ENABLED = "31"; // 'Stable borrowing is not enabled'
     string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = "32"; // 'User cannot withdraw more than the available balance'
     string public constant INVALID_INTEREST_RATE_MODE_SELECTED = "33"; // 'Invalid interest rate mode selected'
     string public constant COLLATERAL_BALANCE_IS_ZERO = "34"; // 'The collateral balance is 0'
@@ -45,10 +44,8 @@ library Errors {
         "35"; // 'Health factor is lesser than the liquidation threshold'
     string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = "36"; // 'There is not enough collateral to cover a new borrow'
     string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = "37"; // 'Collateral is (mostly) the same currency that is being borrowed'
-    string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = "38"; // 'The requested amount is greater than the max loan size in stable rate mode'
     string public constant NO_DEBT_OF_SELECTED_TYPE = "39"; // 'For repayment of a specific type of debt, the user needs to have debt that type'
     string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = "40"; // 'To repay on behalf of a user an explicit amount to repay is needed'
-    string public constant NO_OUTSTANDING_STABLE_DEBT = "41"; // 'User does not have outstanding stable rate debt on this reserve'
     string public constant NO_OUTSTANDING_VARIABLE_DEBT = "42"; // 'User does not have outstanding variable rate debt on this reserve'
     string public constant UNDERLYING_BALANCE_ZERO = "43"; // 'The underlying balance needs to be greater than 0'
     string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = "44"; // 'Interest rate rebalance conditions were not met'
@@ -61,7 +58,6 @@ library Errors {
     string public constant UNBACKED_MINT_CAP_EXCEEDED = "52"; // 'Unbacked mint cap is exceeded'
     string public constant DEBT_CEILING_EXCEEDED = "53"; // 'Debt ceiling is exceeded'
     string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = "54"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'
-    string public constant STABLE_DEBT_NOT_ZERO = "55"; // 'Stable debt supply is not zero'
     string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = "56"; // 'Variable debt supply is not zero'
     string public constant LTV_VALIDATION_FAILED = "57"; // 'Ltv validation failed'
     string public constant INCONSISTENT_EMODE_CATEGORY = "58"; // 'Inconsistent eMode category'
@@ -90,11 +86,9 @@ library Errors {
     string public constant DEBT_CEILING_NOT_ZERO = "81"; // 'Debt ceiling is not zero'
     string public constant ASSET_NOT_LISTED = "82"; // 'Asset is not listed'
     string public constant INVALID_OPTIMAL_USAGE_RATIO = "83"; // 'Invalid optimal usage ratio'
-    string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = "84"; // 'Invalid optimal stable to total debt ratio'
     string public constant UNDERLYING_CANNOT_BE_RESCUED = "85"; // 'The underlying asset cannot be rescued'
     string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = "86"; // 'Reserve has already been added to reserve list'
     string public constant POOL_ADDRESSES_DO_NOT_MATCH = "87"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'
-    string public constant STABLE_BORROWING_ENABLED = "88"; // 'Stable borrowing is enabled'
     string public constant SILOED_BORROWING_VIOLATION = "89"; // 'User is trying to borrow multiple assets including a siloed one'
     string public constant RESERVE_DEBT_NOT_ZERO = "90"; // the total debt of the reserve needs to be 0
     string public constant FLASHLOAN_DISABLED = "91"; // FlashLoaning for this asset is disabled
@@ -106,4 +100,5 @@ library Errors {
     string public constant LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED = "97"; // 'Liquidation grace sentinel validation failed'
     string public constant INVALID_GRACE_PERIOD = "98"; // Grace period above a valid range
     string public constant INVALID_FREEZE_STATE = "99"; // Reserve is already in the passed freeze state
+    string public constant NOT_BORROWABLE_IN_EMODE = "100"; // Asset not borrowable in eMode
 }
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/FlashLoanLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/FlashLoanLogic.sol
index 5b7c1cf..7cd5e95 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/FlashLoanLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/FlashLoanLogic.sol
@@ -6,8 +6,8 @@ import {SafeCast} from "../../../dependencies/openzeppelin/contracts/SafeCast.so
 import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
 import {IAToken} from "../../../interfaces/IAToken.sol";
 import {IPool} from "../../../interfaces/IPool.sol";
-import {IFlashLoanReceiver} from "../../../flashloan/interfaces/IFlashLoanReceiver.sol";
-import {IFlashLoanSimpleReceiver} from "../../../flashloan/interfaces/IFlashLoanSimpleReceiver.sol";
+import {IFlashLoanReceiver} from "../../../misc/flashloan/interfaces/IFlashLoanReceiver.sol";
+import {IFlashLoanSimpleReceiver} from "../../../misc/flashloan/interfaces/IFlashLoanSimpleReceiver.sol";
 import {IPoolAddressesProvider} from "../../../interfaces/IPoolAddressesProvider.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
 import {Errors} from "../helpers/Errors.sol";
@@ -46,7 +46,6 @@ library FlashLoanLogic {
     // Helper struct for internal variables used in the `executeFlashLoan` function
     struct FlashLoanLocalVars {
         IFlashLoanReceiver receiver;
-        uint256 i;
         address currentAsset;
         uint256 currentAmount;
         uint256[] totalPremiums;
@@ -94,24 +93,25 @@ library FlashLoanLogic {
             ? (0, 0)
             : (params.flashLoanPremiumTotal, params.flashLoanPremiumToProtocol);
 
-        for (vars.i = 0; vars.i < params.assets.length; vars.i++) {
-            vars.currentAmount = params.amounts[vars.i];
-            vars.totalPremiums[vars.i] = DataTypes.InterestRateMode(
-                params.interestRateModes[vars.i]
+        for (uint256 i = 0; i < params.assets.length; i++) {
+            vars.currentAmount = params.amounts[i];
+            vars.totalPremiums[i] = DataTypes.InterestRateMode(
+                params.interestRateModes[i]
             ) == DataTypes.InterestRateMode.NONE
                 ? vars.currentAmount.percentMul(vars.flashloanPremiumTotal)
                 : 0;
 
             if (
-                reservesData[params.assets[vars.i]]
+                reservesData[params.assets[i]]
                     .configuration
                     .getIsVirtualAccActive()
             ) {
-                reservesData[params.assets[vars.i]]
-                    .virtualUnderlyingBalance -= vars.currentAmount.toUint128();
+                reservesData[params.assets[i]].virtualUnderlyingBalance -= vars
+                    .currentAmount
+                    .toUint128();
             }
 
-            IAToken(reservesData[params.assets[vars.i]].aTokenAddress)
+            IAToken(reservesData[params.assets[i]].aTokenAddress)
                 .transferUnderlyingTo(
                     params.receiverAddress,
                     vars.currentAmount
@@ -129,12 +129,12 @@ library FlashLoanLogic {
             Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN
         );
 
-        for (vars.i = 0; vars.i < params.assets.length; vars.i++) {
-            vars.currentAsset = params.assets[vars.i];
-            vars.currentAmount = params.amounts[vars.i];
+        for (uint256 i = 0; i < params.assets.length; i++) {
+            vars.currentAsset = params.assets[i];
+            vars.currentAmount = params.amounts[i];
 
             if (
-                DataTypes.InterestRateMode(params.interestRateModes[vars.i]) ==
+                DataTypes.InterestRateMode(params.interestRateModes[i]) ==
                 DataTypes.InterestRateMode.NONE
             ) {
                 _handleFlashLoanRepayment(
@@ -143,7 +143,7 @@ library FlashLoanLogic {
                         asset: vars.currentAsset,
                         receiverAddress: params.receiverAddress,
                         amount: vars.currentAmount,
-                        totalPremium: vars.totalPremiums[vars.i],
+                        totalPremium: vars.totalPremiums[i],
                         flashLoanPremiumToProtocol: vars
                             .flashloanPremiumToProtocol,
                         referralCode: params.referralCode
@@ -163,12 +163,10 @@ library FlashLoanLogic {
                         onBehalfOf: params.onBehalfOf,
                         amount: vars.currentAmount,
                         interestRateMode: DataTypes.InterestRateMode(
-                            params.interestRateModes[vars.i]
+                            params.interestRateModes[i]
                         ),
                         referralCode: params.referralCode,
                         releaseUnderlying: false,
-                        maxStableRateBorrowSizePercent: IPool(params.pool)
-                            .MAX_STABLE_RATE_BORROW_SIZE_PERCENT(),
                         reservesCount: IPool(params.pool).getReservesCount(),
                         oracle: IPoolAddressesProvider(params.addressesProvider)
                             .getPriceOracle(),
@@ -186,9 +184,7 @@ library FlashLoanLogic {
                     msg.sender,
                     vars.currentAsset,
                     vars.currentAmount,
-                    DataTypes.InterestRateMode(
-                        params.interestRateModes[vars.i]
-                    ),
+                    DataTypes.InterestRateMode(params.interestRateModes[i]),
                     0,
                     params.referralCode
                 );
@@ -310,7 +306,7 @@ library FlashLoanLogic {
             msg.sender,
             params.asset,
             params.amount,
-            DataTypes.InterestRateMode(0),
+            DataTypes.InterestRateMode.NONE,
             params.totalPremium,
             params.referralCode
         );
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/GenericLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/GenericLogic.sol
index b61d73d..a3efd9a 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/GenericLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/GenericLogic.sol
@@ -6,6 +6,7 @@ import {IScaledBalanceToken} from "../../../interfaces/IScaledBalanceToken.sol";
 import {IPriceOracleGetter} from "../../../interfaces/IPriceOracleGetter.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
 import {UserConfiguration} from "../configuration/UserConfiguration.sol";
+import {EModeConfiguration} from "../configuration/EModeConfiguration.sol";
 import {PercentageMath} from "../math/PercentageMath.sol";
 import {WadRayMath} from "../math/WadRayMath.sol";
 import {DataTypes} from "../types/DataTypes.sol";
@@ -37,10 +38,8 @@ library GenericLogic {
         uint256 totalDebtInBaseCurrency;
         uint256 avgLtv;
         uint256 avgLiquidationThreshold;
-        uint256 eModeAssetPrice;
         uint256 eModeLtv;
         uint256 eModeLiqThreshold;
-        uint256 eModeAssetCategory;
         address currentReserveAddress;
         bool hasZeroLtvCollateral;
         bool isInEModeCategory;
@@ -78,14 +77,9 @@ library GenericLogic {
         CalculateUserAccountDataVars memory vars;
 
         if (params.userEModeCategory != 0) {
-            (
-                vars.eModeLtv,
-                vars.eModeLiqThreshold,
-                vars.eModeAssetPrice
-            ) = EModeLogic.getEModeConfiguration(
-                eModeCategories[params.userEModeCategory],
-                IPriceOracleGetter(params.oracle)
-            );
+            vars.eModeLtv = eModeCategories[params.userEModeCategory].ltv;
+            vars.eModeLiqThreshold = eModeCategories[params.userEModeCategory]
+                .liquidationThreshold;
         }
 
         while (vars.i < params.reservesCount) {
@@ -114,20 +108,16 @@ library GenericLogic {
                 vars.liquidationThreshold,
                 ,
                 vars.decimals,
-                ,
-                vars.eModeAssetCategory
+
             ) = currentReserve.configuration.getParams();
 
             unchecked {
                 vars.assetUnit = 10 ** vars.decimals;
             }
 
-            vars.assetPrice = vars.eModeAssetPrice != 0 &&
-                params.userEModeCategory == vars.eModeAssetCategory
-                ? vars.eModeAssetPrice
-                : IPriceOracleGetter(params.oracle).getAssetPrice(
-                    vars.currentReserveAddress
-                );
+            vars.assetPrice = IPriceOracleGetter(params.oracle).getAssetPrice(
+                vars.currentReserveAddress
+            );
 
             if (
                 vars.liquidationThreshold != 0 &&
@@ -143,10 +133,13 @@ library GenericLogic {
                 vars.totalCollateralInBaseCurrency += vars
                     .userBalanceInBaseCurrency;
 
-                vars.isInEModeCategory = EModeLogic.isInEModeCategory(
-                    params.userEModeCategory,
-                    vars.eModeAssetCategory
-                );
+                vars.isInEModeCategory =
+                    params.userEModeCategory != 0 &&
+                    EModeConfiguration.isReserveEnabledOnBitmap(
+                        eModeCategories[params.userEModeCategory]
+                            .collateralBitmap,
+                        vars.i
+                    );
 
                 if (vars.ltv != 0) {
                     vars.avgLtv +=
@@ -223,7 +216,7 @@ library GenericLogic {
         uint256 availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency
             .percentMul(ltv);
 
-        if (availableBorrowsInBaseCurrency < totalDebtInBaseCurrency) {
+        if (availableBorrowsInBaseCurrency <= totalDebtInBaseCurrency) {
             return 0;
         }
 
@@ -235,7 +228,7 @@ library GenericLogic {
 
     /**
      * @notice Calculates total debt of the user in the based currency used to normalize the values of the assets
-     * @dev This fetches the `balanceOf` of the stable and variable debt tokens for the user. For gas reasons, the
+     * @dev This fetches the `balanceOf` of the variable debt token for the user. For gas reasons, the
      * variable debt balance is calculated by fetching `scaledBalancesOf` normalized debt, which is cheaper than
      * fetching `balanceOf`
      * @param user The address of the user
@@ -254,16 +247,13 @@ library GenericLogic {
         uint256 userTotalDebt = IScaledBalanceToken(
             reserve.variableDebtTokenAddress
         ).scaledBalanceOf(user);
-        if (userTotalDebt != 0) {
-            userTotalDebt = userTotalDebt.rayMul(reserve.getNormalizedDebt());
+        if (userTotalDebt == 0) {
+            return 0;
         }
 
         userTotalDebt =
-            userTotalDebt +
-            IERC20(reserve.stableDebtTokenAddress).balanceOf(user);
-
-        userTotalDebt = assetPrice * userTotalDebt;
-
+            userTotalDebt.rayMul(reserve.getNormalizedDebt()) *
+            assetPrice;
         unchecked {
             return userTotalDebt / assetUnit;
         }
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/Helpers.sol b/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/Helpers.sol
deleted file mode 100644
index bf1903f..0000000
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/Helpers.sol
+++ /dev/null
@@ -1,28 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.0;
-
-import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
-import {DataTypes} from "../types/DataTypes.sol";
-
-/**
- * @title Helpers library
- * @author Aave
- */
-library Helpers {
-    /**
-     * @notice Fetches the user current stable and variable debt balances
-     * @param user The user address
-     * @param reserveCache The reserve cache data object
-     * @return The stable debt balance
-     * @return The variable debt balance
-     */
-    function getUserCurrentDebt(
-        address user,
-        DataTypes.ReserveCache memory reserveCache
-    ) internal view returns (uint256, uint256) {
-        return (
-            IERC20(reserveCache.stableDebtTokenAddress).balanceOf(user),
-            IERC20(reserveCache.variableDebtTokenAddress).balanceOf(user)
-        );
-    }
-}
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IFlashLoanReceiver.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IFlashLoanReceiver.sol
index a034f31..28fd959 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IFlashLoanReceiver.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IFlashLoanReceiver.sol
@@ -1,8 +1,8 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.0;
 
-import {IPoolAddressesProvider} from "../../interfaces/IPoolAddressesProvider.sol";
-import {IPool} from "../../interfaces/IPool.sol";
+import {IPoolAddressesProvider} from "../../../interfaces/IPoolAddressesProvider.sol";
+import {IPool} from "../../../interfaces/IPool.sol";
 
 /**
  * @title IFlashLoanReceiver
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IFlashLoanSimpleReceiver.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IFlashLoanSimpleReceiver.sol
index 8e5eda8..3e139f0 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IFlashLoanSimpleReceiver.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IFlashLoanSimpleReceiver.sol
@@ -1,8 +1,8 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.0;
 
-import {IPoolAddressesProvider} from "../../interfaces/IPoolAddressesProvider.sol";
-import {IPool} from "../../interfaces/IPool.sol";
+import {IPoolAddressesProvider} from "../../../interfaces/IPoolAddressesProvider.sol";
+import {IPool} from "../../../interfaces/IPool.sol";
 
 /**
  * @title IFlashLoanSimpleReceiver
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IPool.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IPool.sol
index 6db17fc..3561fff 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IPool.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IPool.sol
@@ -77,7 +77,7 @@ interface IPool {
      * initiator of the transaction on flashLoan()
      * @param onBehalfOf The address that will be getting the debt
      * @param amount The amount borrowed out
-     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable
+     * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)
      * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray
      * @param referralCode The referral code used
      */
@@ -107,18 +107,6 @@ interface IPool {
         bool useATokens
     );
 
-    /**
-     * @dev Emitted on swapBorrowRateMode()
-     * @param reserve The address of the underlying asset of the reserve
-     * @param user The address of the user swapping his rate mode
-     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable
-     */
-    event SwapBorrowRateMode(
-        address indexed reserve,
-        address indexed user,
-        DataTypes.InterestRateMode interestRateMode
-    );
-
     /**
      * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets
      * @param asset The address of the underlying asset of the reserve
@@ -156,23 +144,14 @@ interface IPool {
         address indexed user
     );
 
-    /**
-     * @dev Emitted on rebalanceStableBorrowRate()
-     * @param reserve The address of the underlying asset of the reserve
-     * @param user The address of the user for which the rebalance has been executed
-     */
-    event RebalanceStableBorrowRate(
-        address indexed reserve,
-        address indexed user
-    );
-
     /**
      * @dev Emitted on flashLoan()
      * @param target The address of the flash loan receiver contract
      * @param initiator The address initiating the flash loan
      * @param asset The address of the asset being flash borrowed
      * @param amount The amount flash borrowed
-     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt
+     * @param interestRateMode The flashloan mode: 0 for regular flashloan,
+     *        1 for Stable (Deprecated on v3.2.0), 2 for Variable
      * @param premium The fee flash borrowed
      * @param referralCode The referral code used
      */
@@ -211,7 +190,7 @@ interface IPool {
      * @dev Emitted when the state of a reserve is updated.
      * @param reserve The address of the underlying asset of the reserve
      * @param liquidityRate The next liquidity rate
-     * @param stableBorrowRate The next stable borrow rate
+     * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0
      * @param variableBorrowRate The next variable borrow rate
      * @param liquidityIndex The next liquidity index
      * @param variableBorrowIndex The next variable borrow index
@@ -323,13 +302,12 @@ interface IPool {
 
     /**
      * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
-     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the
-     * corresponding debt token (StableDebtToken or VariableDebtToken)
+     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken
      * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
-     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
+     *   and 100 variable debt tokens
      * @param asset The address of the underlying asset to borrow
      * @param amount The amount to be borrowed
-     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
      *   0 if the action is executed directly by the user, without any middle-man
      * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself
@@ -346,11 +324,11 @@ interface IPool {
 
     /**
      * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
-     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
+     * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the
      * user calling the function if he wants to reduce/remove his own debt, or the address of any other
      * other borrower whose debt should be removed
@@ -369,7 +347,7 @@ interface IPool {
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
      * user calling the function if he wants to reduce/remove his own debt, or the address of any other
      * other borrower whose debt should be removed
@@ -393,13 +371,13 @@ interface IPool {
     /**
      * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the
      * equivalent debt tokens
-     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens
+     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens
      * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken
      * balance is not enough to cover the whole debt
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode DEPRECATED in v3.2.0
      * @return The final amount repaid
      */
     function repayWithATokens(
@@ -408,35 +386,6 @@ interface IPool {
         uint256 interestRateMode
     ) external returns (uint256);
 
-    /**
-     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa
-     * @param asset The address of the underlying asset borrowed
-     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable
-     */
-    function swapBorrowRateMode(
-        address asset,
-        uint256 interestRateMode
-    ) external;
-
-    /**
-     * @notice Permissionless method which allows anyone to swap a users stable debt to variable debt
-     * @dev Introduced in favor of stable rate deprecation
-     * @param asset The address of the underlying asset borrowed
-     * @param user The address of the user whose debt will be swapped from stable to variable
-     */
-    function swapToVariable(address asset, address user) external;
-
-    /**
-     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
-     * - Users can be rebalanced if the following conditions are satisfied:
-     *     1. Usage ratio is above 95%
-     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too
-     *        much has been borrowed at a stable rate and suppliers are not earning enough
-     * @param asset The address of the underlying asset borrowed
-     * @param user The address of the user to be rebalanced
-     */
-    function rebalanceStableBorrowRate(address asset, address user) external;
-
     /**
      * @notice Allows suppliers to enable/disable a specific supplied asset as collateral
      * @param asset The address of the underlying asset supplied
@@ -476,9 +425,9 @@ interface IPool {
      * @param amounts The amounts of the assets being flash-borrowed
      * @param interestRateModes Types of the debt to open if the flash loan is not returned:
      *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
-     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
+     *   1 -> Deprecated on v3.2.0
      *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
-     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
+     * @param onBehalfOf The address  that will receive the debt in the case of using 2 on `modes`
      * @param params Variadic packed params to pass to the receiver as extra information
      * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
      *   0 if the action is executed directly by the user, without any middle-man
@@ -543,14 +492,12 @@ interface IPool {
      * @dev Only callable by the PoolConfigurator contract
      * @param asset The address of the underlying asset of the reserve
      * @param aTokenAddress The address of the aToken that will be assigned to the reserve
-     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve
      * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve
      * @param interestRateStrategyAddress The address of the interest rate strategy contract
      */
     function initReserve(
         address asset,
         address aTokenAddress,
-        address stableDebtAddress,
         address variableDebtAddress,
         address interestRateStrategyAddress
     ) external;
@@ -558,6 +505,7 @@ interface IPool {
     /**
      * @notice Drop a reserve
      * @dev Only callable by the PoolConfigurator contract
+     * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.
      * @param asset The address of the underlying asset of the reserve
      */
     function dropReserve(address asset) external;
@@ -741,7 +689,7 @@ interface IPool {
     ) external;
 
     /**
-     * @notice Configures a new category for the eMode.
+     * @notice Configures a new or alters an existing collateral configuration of an eMode.
      * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.
      * The category 0 is reserved as it's the default for volatile assets
      * @param id The id of the category
@@ -749,17 +697,74 @@ interface IPool {
      */
     function configureEModeCategory(
         uint8 id,
-        DataTypes.EModeCategory memory config
+        DataTypes.EModeCategoryBaseConfiguration memory config
+    ) external;
+
+    /**
+     * @notice Replaces the current eMode collateralBitmap.
+     * @param id The id of the category
+     * @param collateralBitmap The collateralBitmap of the category
+     */
+    function configureEModeCategoryCollateralBitmap(
+        uint8 id,
+        uint128 collateralBitmap
+    ) external;
+
+    /**
+     * @notice Replaces the current eMode borrowableBitmap.
+     * @param id The id of the category
+     * @param borrowableBitmap The borrowableBitmap of the category
+     */
+    function configureEModeCategoryBorrowableBitmap(
+        uint8 id,
+        uint128 borrowableBitmap
     ) external;
 
     /**
      * @notice Returns the data of an eMode category
+     * @dev DEPRECATED use independent getters instead
      * @param id The id of the category
      * @return The configuration data of the category
      */
     function getEModeCategoryData(
         uint8 id
-    ) external view returns (DataTypes.EModeCategory memory);
+    ) external view returns (DataTypes.EModeCategoryLegacy memory);
+
+    /**
+     * @notice Returns the label of an eMode category
+     * @param id The id of the category
+     * @return The label of the category
+     */
+    function getEModeCategoryLabel(
+        uint8 id
+    ) external view returns (string memory);
+
+    /**
+     * @notice Returns the collateral config of an eMode category
+     * @param id The id of the category
+     * @return The ltv,lt,lb of the category
+     */
+    function getEModeCategoryCollateralConfig(
+        uint8 id
+    ) external view returns (DataTypes.CollateralConfig memory);
+
+    /**
+     * @notice Returns the collateralBitmap of an eMode category
+     * @param id The id of the category
+     * @return The collateralBitmap of the category
+     */
+    function getEModeCategoryCollateralBitmap(
+        uint8 id
+    ) external view returns (uint128);
+
+    /**
+     * @notice Returns the borrowableBitmap of an eMode category
+     * @param id The id of the category
+     * @return The borrowableBitmap of the category
+     */
+    function getEModeCategoryBorrowableBitmap(
+        uint8 id
+    ) external view returns (uint128);
 
     /**
      * @notice Allows a user to use the protocol in eMode
@@ -797,15 +802,6 @@ interface IPool {
      **/
     function getLiquidationGracePeriod(address asset) external returns (uint40);
 
-    /**
-     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate
-     * @return The percentage of available liquidity to borrow, expressed in bps
-     */
-    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()
-        external
-        view
-        returns (uint256);
-
     /**
      * @notice Returns the total fee on flash loans
      * @return The total fee on flashloans
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IReserveInterestRateStrategy.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IReserveInterestRateStrategy.sol
index 23ecb45..338d93a 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IReserveInterestRateStrategy.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IReserveInterestRateStrategy.sol
@@ -24,10 +24,9 @@ interface IReserveInterestRateStrategy {
      * @notice Calculates the interest rates depending on the reserve's state and configurations
      * @param params The parameters needed to calculate interest rates
      * @return liquidityRate The liquidity rate expressed in ray
-     * @return stableBorrowRate The stable borrow rate expressed in ray
      * @return variableBorrowRate The variable borrow rate expressed in ray
      */
     function calculateInterestRates(
         DataTypes.CalculateInterestRatesParams memory params
-    ) external view returns (uint256, uint256, uint256);
+    ) external view returns (uint256, uint256);
 }
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IStableDebtToken.sol b/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IStableDebtToken.sol
deleted file mode 100644
index 7e4b84e..0000000
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IStableDebtToken.sol
+++ /dev/null
@@ -1,148 +0,0 @@
-// SPDX-License-Identifier: MIT
-pragma solidity ^0.8.0;
-
-import {IInitializableDebtToken} from "./IInitializableDebtToken.sol";
-
-/**
- * @title IStableDebtToken
- * @author Aave
- * @notice Defines the interface for the stable debt token
- * @dev It does not inherit from IERC20 to save in code size
- */
-interface IStableDebtToken is IInitializableDebtToken {
-    /**
-     * @dev Emitted when new stable debt is minted
-     * @param user The address of the user who triggered the minting
-     * @param onBehalfOf The recipient of stable debt tokens
-     * @param amount The amount minted (user entered amount + balance increase from interest)
-     * @param currentBalance The balance of the user based on the previous balance and balance increase from interest
-     * @param balanceIncrease The increase in balance since the last action of the user 'onBehalfOf'
-     * @param newRate The rate of the debt after the minting
-     * @param avgStableRate The next average stable rate after the minting
-     * @param newTotalSupply The next total supply of the stable debt token after the action
-     */
-    event Mint(
-        address indexed user,
-        address indexed onBehalfOf,
-        uint256 amount,
-        uint256 currentBalance,
-        uint256 balanceIncrease,
-        uint256 newRate,
-        uint256 avgStableRate,
-        uint256 newTotalSupply
-    );
-
-    /**
-     * @dev Emitted when new stable debt is burned
-     * @param from The address from which the debt will be burned
-     * @param amount The amount being burned (user entered amount - balance increase from interest)
-     * @param currentBalance The balance of the user based on the previous balance and balance increase from interest
-     * @param balanceIncrease The increase in balance since the last action of 'from'
-     * @param avgStableRate The next average stable rate after the burning
-     * @param newTotalSupply The next total supply of the stable debt token after the action
-     */
-    event Burn(
-        address indexed from,
-        uint256 amount,
-        uint256 currentBalance,
-        uint256 balanceIncrease,
-        uint256 avgStableRate,
-        uint256 newTotalSupply
-    );
-
-    /**
-     * @notice Mints debt token to the `onBehalfOf` address.
-     * @dev The resulting rate is the weighted average between the rate of the new debt
-     * and the rate of the previous debt
-     * @param user The address receiving the borrowed underlying, being the delegatee in case
-     * of credit delegate, or same as `onBehalfOf` otherwise
-     * @param onBehalfOf The address receiving the debt tokens
-     * @param amount The amount of debt tokens to mint
-     * @param rate The rate of the debt being minted
-     * @return True if it is the first borrow, false otherwise
-     * @return The total stable debt
-     * @return The average stable borrow rate
-     */
-    function mint(
-        address user,
-        address onBehalfOf,
-        uint256 amount,
-        uint256 rate
-    ) external returns (bool, uint256, uint256);
-
-    /**
-     * @notice Burns debt of `user`
-     * @dev The resulting rate is the weighted average between the rate of the new debt
-     * and the rate of the previous debt
-     * @dev In some instances, a burn transaction will emit a mint event
-     * if the amount to burn is less than the interest the user earned
-     * @param from The address from which the debt will be burned
-     * @param amount The amount of debt tokens getting burned
-     * @return The total stable debt
-     * @return The average stable borrow rate
-     */
-    function burn(
-        address from,
-        uint256 amount
-    ) external returns (uint256, uint256);
-
-    /**
-     * @notice Returns the average rate of all the stable rate loans.
-     * @return The average stable rate
-     */
-    function getAverageStableRate() external view returns (uint256);
-
-    /**
-     * @notice Returns the stable rate of the user debt
-     * @param user The address of the user
-     * @return The stable rate of the user
-     */
-    function getUserStableRate(address user) external view returns (uint256);
-
-    /**
-     * @notice Returns the timestamp of the last update of the user
-     * @param user The address of the user
-     * @return The timestamp
-     */
-    function getUserLastUpdated(address user) external view returns (uint40);
-
-    /**
-     * @notice Returns the principal, the total supply, the average stable rate and the timestamp for the last update
-     * @return The principal
-     * @return The total supply
-     * @return The average stable rate
-     * @return The timestamp of the last update
-     */
-    function getSupplyData()
-        external
-        view
-        returns (uint256, uint256, uint256, uint40);
-
-    /**
-     * @notice Returns the timestamp of the last update of the total supply
-     * @return The timestamp
-     */
-    function getTotalSupplyLastUpdated() external view returns (uint40);
-
-    /**
-     * @notice Returns the total supply and the average stable rate
-     * @return The total supply
-     * @return The average rate
-     */
-    function getTotalSupplyAndAvgRate()
-        external
-        view
-        returns (uint256, uint256);
-
-    /**
-     * @notice Returns the principal debt balance of the user
-     * @return The debt balance of the user since the last burn/mint action
-     */
-    function principalBalanceOf(address user) external view returns (uint256);
-
-    /**
-     * @notice Returns the address of the underlying asset of this stableDebtToken (E.g. WETH for stableDebtWETH)
-     * @return The address of the underlying asset
-     */
-    function UNDERLYING_ASSET_ADDRESS() external view returns (address);
-}
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IncentivizedERC20.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IncentivizedERC20.sol
index 457a5af..d1d7619 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/IncentivizedERC20.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/IncentivizedERC20.sol
@@ -46,8 +46,7 @@ abstract contract IncentivizedERC20 is Context, IERC20Detailed {
     /**
      * @dev UserState - additionalData is a flexible field.
      * ATokens and VariableDebtTokens use this field store the index of the
-     * user's last supply/withdrawal/borrow/repayment. StableDebtTokens use
-     * this field to store the user's stable rate.
+     * user's last supply/withdrawal/borrow/repayment.
      */
     struct UserState {
         uint128 balance;
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/LiquidationLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/LiquidationLogic.sol
index 7dc4f81..51793b6 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/LiquidationLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/LiquidationLogic.sol
@@ -5,7 +5,6 @@ import {IERC20} from "../../../dependencies/openzeppelin/contracts//IERC20.sol";
 import {GPv2SafeERC20} from "../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
 import {PercentageMath} from "../../libraries/math/PercentageMath.sol";
 import {WadRayMath} from "../../libraries/math/WadRayMath.sol";
-import {Helpers} from "../../libraries/helpers/Helpers.sol";
 import {DataTypes} from "../../libraries/types/DataTypes.sol";
 import {ReserveLogic} from "./ReserveLogic.sol";
 import {ValidationLogic} from "./ValidationLogic.sol";
@@ -14,8 +13,8 @@ import {IsolationModeLogic} from "./IsolationModeLogic.sol";
 import {EModeLogic} from "./EModeLogic.sol";
 import {UserConfiguration} from "../../libraries/configuration/UserConfiguration.sol";
 import {ReserveConfiguration} from "../../libraries/configuration/ReserveConfiguration.sol";
+import {EModeConfiguration} from "../../libraries/configuration/EModeConfiguration.sol";
 import {IAToken} from "../../../interfaces/IAToken.sol";
-import {IStableDebtToken} from "../../../interfaces/IStableDebtToken.sol";
 import {IVariableDebtToken} from "../../../interfaces/IVariableDebtToken.sol";
 import {IPriceOracleGetter} from "../../../interfaces/IPriceOracleGetter.sol";
 
@@ -75,15 +74,12 @@ library LiquidationLogic {
 
     struct LiquidationCallLocalVars {
         uint256 userCollateralBalance;
-        uint256 userVariableDebt;
         uint256 userTotalDebt;
         uint256 actualDebtToLiquidate;
         uint256 actualCollateralToLiquidate;
         uint256 liquidationBonus;
         uint256 healthFactor;
         uint256 liquidationProtocolFeeAmount;
-        address collateralPriceSource;
-        address debtPriceSource;
         IAToken collateralAToken;
         DataTypes.ReserveCache debtReserveCache;
     }
@@ -133,11 +129,11 @@ library LiquidationLogic {
             })
         );
 
-        (
-            vars.userVariableDebt,
-            vars.userTotalDebt,
-            vars.actualDebtToLiquidate
-        ) = _calculateDebt(vars.debtReserveCache, params, vars.healthFactor);
+        (vars.userTotalDebt, vars.actualDebtToLiquidate) = _calculateDebt(
+            vars.debtReserveCache,
+            params,
+            vars.healthFactor
+        );
 
         ValidationLogic.validateLiquidationCall(
             userConfig,
@@ -151,12 +147,21 @@ library LiquidationLogic {
             })
         );
 
-        (
-            vars.collateralAToken,
-            vars.collateralPriceSource,
-            vars.debtPriceSource,
-            vars.liquidationBonus
-        ) = _getConfigurationData(eModeCategories, collateralReserve, params);
+        vars.collateralAToken = IAToken(collateralReserve.aTokenAddress);
+        if (
+            params.userEModeCategory != 0 &&
+            EModeConfiguration.isReserveEnabledOnBitmap(
+                eModeCategories[params.userEModeCategory].collateralBitmap,
+                collateralReserve.id
+            )
+        ) {
+            vars.liquidationBonus = eModeCategories[params.userEModeCategory]
+                .liquidationBonus;
+        } else {
+            vars.liquidationBonus = collateralReserve
+                .configuration
+                .getLiquidationBonus();
+        }
 
         vars.userCollateralBalance = vars.collateralAToken.balanceOf(
             params.user
@@ -169,8 +174,8 @@ library LiquidationLogic {
         ) = _calculateAvailableCollateralToLiquidate(
             collateralReserve,
             vars.debtReserveCache,
-            vars.collateralPriceSource,
-            vars.debtPriceSource,
+            params.collateralAsset,
+            params.debtAsset,
             vars.actualDebtToLiquidate,
             vars.userCollateralBalance,
             vars.liquidationBonus,
@@ -362,36 +367,13 @@ library LiquidationLogic {
         DataTypes.ExecuteLiquidationCallParams memory params,
         LiquidationCallLocalVars memory vars
     ) internal {
-        if (vars.userVariableDebt >= vars.actualDebtToLiquidate) {
-            vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(
-                vars.debtReserveCache.variableDebtTokenAddress
-            ).burn(
-                    params.user,
-                    vars.actualDebtToLiquidate,
-                    vars.debtReserveCache.nextVariableBorrowIndex
-                );
-        } else {
-            // If the user doesn't have variable debt, no need to try to burn variable debt tokens
-            if (vars.userVariableDebt != 0) {
-                vars
-                    .debtReserveCache
-                    .nextScaledVariableDebt = IVariableDebtToken(
-                    vars.debtReserveCache.variableDebtTokenAddress
-                ).burn(
-                        params.user,
-                        vars.userVariableDebt,
-                        vars.debtReserveCache.nextVariableBorrowIndex
-                    );
-            }
-            (
-                vars.debtReserveCache.nextTotalStableDebt,
-                vars.debtReserveCache.nextAvgStableBorrowRate
-            ) = IStableDebtToken(vars.debtReserveCache.stableDebtTokenAddress)
-                .burn(
-                    params.user,
-                    vars.actualDebtToLiquidate - vars.userVariableDebt
-                );
-        }
+        vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(
+            vars.debtReserveCache.variableDebtTokenAddress
+        ).burn(
+                params.user,
+                vars.actualDebtToLiquidate,
+                vars.debtReserveCache.nextVariableBorrowIndex
+            );
     }
 
     /**
@@ -401,7 +383,6 @@ library LiquidationLogic {
      * @param debtReserveCache The reserve cache data object of the debt reserve
      * @param params The additional parameters needed to execute the liquidation function
      * @param healthFactor The health factor of the position
-     * @return The variable debt of the user
      * @return The total debt of the user
      * @return The actual debt to liquidate as a function of the closeFactor
      */
@@ -409,78 +390,22 @@ library LiquidationLogic {
         DataTypes.ReserveCache memory debtReserveCache,
         DataTypes.ExecuteLiquidationCallParams memory params,
         uint256 healthFactor
-    ) internal view returns (uint256, uint256, uint256) {
-        (uint256 userStableDebt, uint256 userVariableDebt) = Helpers
-            .getUserCurrentDebt(params.user, debtReserveCache);
-
-        uint256 userTotalDebt = userStableDebt + userVariableDebt;
+    ) internal view returns (uint256, uint256) {
+        uint256 userVariableDebt = IERC20(
+            debtReserveCache.variableDebtTokenAddress
+        ).balanceOf(params.user);
 
         uint256 closeFactor = healthFactor > CLOSE_FACTOR_HF_THRESHOLD
             ? DEFAULT_LIQUIDATION_CLOSE_FACTOR
             : MAX_LIQUIDATION_CLOSE_FACTOR;
 
-        uint256 maxLiquidatableDebt = userTotalDebt.percentMul(closeFactor);
+        uint256 maxLiquidatableDebt = userVariableDebt.percentMul(closeFactor);
 
         uint256 actualDebtToLiquidate = params.debtToCover > maxLiquidatableDebt
             ? maxLiquidatableDebt
             : params.debtToCover;
 
-        return (userVariableDebt, userTotalDebt, actualDebtToLiquidate);
-    }
-
-    /**
-     * @notice Returns the configuration data for the debt and the collateral reserves.
-     * @param eModeCategories The configuration of all the efficiency mode categories
-     * @param collateralReserve The data of the collateral reserve
-     * @param params The additional parameters needed to execute the liquidation function
-     * @return The collateral aToken
-     * @return The address to use as price source for the collateral
-     * @return The address to use as price source for the debt
-     * @return The liquidation bonus to apply to the collateral
-     */
-    function _getConfigurationData(
-        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
-        DataTypes.ReserveData storage collateralReserve,
-        DataTypes.ExecuteLiquidationCallParams memory params
-    ) internal view returns (IAToken, address, address, uint256) {
-        IAToken collateralAToken = IAToken(collateralReserve.aTokenAddress);
-        uint256 liquidationBonus = collateralReserve
-            .configuration
-            .getLiquidationBonus();
-
-        address collateralPriceSource = params.collateralAsset;
-        address debtPriceSource = params.debtAsset;
-
-        if (params.userEModeCategory != 0) {
-            address eModePriceSource = eModeCategories[params.userEModeCategory]
-                .priceSource;
-
-            if (
-                EModeLogic.isInEModeCategory(
-                    params.userEModeCategory,
-                    collateralReserve.configuration.getEModeCategory()
-                )
-            ) {
-                liquidationBonus = eModeCategories[params.userEModeCategory]
-                    .liquidationBonus;
-
-                if (eModePriceSource != address(0)) {
-                    collateralPriceSource = eModePriceSource;
-                }
-            }
-
-            // when in eMode, debt will always be in the same eMode category, can skip matching category check
-            if (eModePriceSource != address(0)) {
-                debtPriceSource = eModePriceSource;
-            }
-        }
-
-        return (
-            collateralAToken,
-            collateralPriceSource,
-            debtPriceSource,
-            liquidationBonus
-        );
+        return (userVariableDebt, actualDebtToLiquidate);
     }
 
     struct AvailableCollateralToLiquidateLocalVars {
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/Pool.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/Pool.sol
index ab97ad7..d46f444 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/Pool.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/Pool.sol
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: BUSL-1.1
 pragma solidity ^0.8.10;
 
-import {VersionedInitializable} from "../libraries/aave-upgradeability/VersionedInitializable.sol";
+import {VersionedInitializable} from "../../misc/aave-upgradeability/VersionedInitializable.sol";
 import {Errors} from "../libraries/helpers/Errors.sol";
 import {ReserveConfiguration} from "../libraries/configuration/ReserveConfiguration.sol";
 import {PoolLogic} from "../libraries/logic/PoolLogic.sol";
@@ -28,8 +28,7 @@ import {PoolStorage} from "./PoolStorage.sol";
  *   # Withdraw
  *   # Borrow
  *   # Repay
- *   # Swap their loans between variable and stable rate
- *   # Enable/disable their supplied assets as collateral rebalance stable rate borrow positions
+ *   # Enable/disable their supplied assets as collateral
  *   # Liquidate positions
  *   # Execute Flash Loans
  * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market
@@ -240,7 +239,6 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
                 interestRateMode: DataTypes.InterestRateMode(interestRateMode),
                 referralCode: referralCode,
                 releaseUnderlying: true,
-                maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,
                 reservesCount: _reservesCount,
                 oracle: ADDRESSES_PROVIDER.getPriceOracle(),
                 userEModeCategory: _usersEModeCategory[onBehalfOf],
@@ -340,46 +338,6 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
             );
     }
 
-    /// @inheritdoc IPool
-    function swapBorrowRateMode(
-        address asset,
-        uint256 interestRateMode
-    ) public virtual override {
-        BorrowLogic.executeSwapBorrowRateMode(
-            _reserves[asset],
-            _usersConfig[msg.sender],
-            asset,
-            msg.sender,
-            DataTypes.InterestRateMode(interestRateMode)
-        );
-    }
-
-    /// @inheritdoc IPool
-    function swapToVariable(
-        address asset,
-        address user
-    ) public virtual override {
-        BorrowLogic.executeSwapBorrowRateMode(
-            _reserves[asset],
-            _usersConfig[user],
-            asset,
-            user,
-            DataTypes.InterestRateMode.STABLE
-        );
-    }
-
-    /// @inheritdoc IPool
-    function rebalanceStableBorrowRate(
-        address asset,
-        address user
-    ) public virtual override {
-        BorrowLogic.executeRebalanceStableBorrowRate(
-            _reserves[asset],
-            asset,
-            user
-        );
-    }
-
     /// @inheritdoc IPool
     function setUserUseReserveAsCollateral(
         address asset,
@@ -446,7 +404,6 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
                 referralCode: referralCode,
                 flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,
                 flashLoanPremiumTotal: _flashLoanPremiumTotal,
-                maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,
                 reservesCount: _reservesCount,
                 addressesProvider: address(ADDRESSES_PROVIDER),
                 pool: address(this),
@@ -518,11 +475,9 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
         res.currentLiquidityRate = reserve.currentLiquidityRate;
         res.variableBorrowIndex = reserve.variableBorrowIndex;
         res.currentVariableBorrowRate = reserve.currentVariableBorrowRate;
-        res.currentStableBorrowRate = reserve.currentStableBorrowRate;
         res.lastUpdateTimestamp = reserve.lastUpdateTimestamp;
         res.id = reserve.id;
         res.aTokenAddress = reserve.aTokenAddress;
-        res.stableDebtTokenAddress = reserve.stableDebtTokenAddress;
         res.variableDebtTokenAddress = reserve.variableDebtTokenAddress;
         res.interestRateStrategyAddress = reserve.interestRateStrategyAddress;
         res.accruedToTreasury = reserve.accruedToTreasury;
@@ -653,17 +608,6 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
         return _reservesList[id];
     }
 
-    /// @inheritdoc IPool
-    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()
-        public
-        view
-        virtual
-        override
-        returns (uint256)
-    {
-        return _maxStableRateBorrowSizePercent;
-    }
-
     /// @inheritdoc IPool
     function BRIDGE_PROTOCOL_FEE()
         public
@@ -744,7 +688,6 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
     function initReserve(
         address asset,
         address aTokenAddress,
-        address stableDebtAddress,
         address variableDebtAddress,
         address interestRateStrategyAddress
     ) external virtual override onlyPoolConfigurator {
@@ -755,7 +698,6 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
                 DataTypes.InitReserveParams({
                     asset: asset,
                     aTokenAddress: aTokenAddress,
-                    stableDebtAddress: stableDebtAddress,
                     variableDebtAddress: variableDebtAddress,
                     interestRateStrategyAddress: interestRateStrategyAddress,
                     reservesCount: _reservesCount,
@@ -846,18 +788,89 @@ abstract contract Pool is VersionedInitializable, PoolStorage, IPool {
     /// @inheritdoc IPool
     function configureEModeCategory(
         uint8 id,
-        DataTypes.EModeCategory memory category
+        DataTypes.EModeCategoryBaseConfiguration memory category
+    ) external virtual override onlyPoolConfigurator {
+        // category 0 is reserved for volatile heterogeneous assets and it's always disabled
+        require(id != 0, Errors.EMODE_CATEGORY_RESERVED);
+        _eModeCategories[id].ltv = category.ltv;
+        _eModeCategories[id].liquidationThreshold = category
+            .liquidationThreshold;
+        _eModeCategories[id].liquidationBonus = category.liquidationBonus;
+        _eModeCategories[id].label = category.label;
+    }
+
+    /// @inheritdoc IPool
+    function configureEModeCategoryCollateralBitmap(
+        uint8 id,
+        uint128 collateralBitmap
     ) external virtual override onlyPoolConfigurator {
         // category 0 is reserved for volatile heterogeneous assets and it's always disabled
         require(id != 0, Errors.EMODE_CATEGORY_RESERVED);
-        _eModeCategories[id] = category;
+        _eModeCategories[id].collateralBitmap = collateralBitmap;
+    }
+
+    /// @inheritdoc IPool
+    function configureEModeCategoryBorrowableBitmap(
+        uint8 id,
+        uint128 borrowableBitmap
+    ) external virtual override onlyPoolConfigurator {
+        // category 0 is reserved for volatile heterogeneous assets and it's always disabled
+        require(id != 0, Errors.EMODE_CATEGORY_RESERVED);
+        _eModeCategories[id].borrowableBitmap = borrowableBitmap;
     }
 
     /// @inheritdoc IPool
     function getEModeCategoryData(
         uint8 id
-    ) external view virtual override returns (DataTypes.EModeCategory memory) {
-        return _eModeCategories[id];
+    )
+        external
+        view
+        virtual
+        override
+        returns (DataTypes.EModeCategoryLegacy memory)
+    {
+        DataTypes.EModeCategory memory category = _eModeCategories[id];
+        return
+            DataTypes.EModeCategoryLegacy({
+                ltv: category.ltv,
+                liquidationThreshold: category.liquidationThreshold,
+                liquidationBonus: category.liquidationBonus,
+                priceSource: address(0),
+                label: category.label
+            });
+    }
+
+    /// @inheritdoc IPool
+    function getEModeCategoryCollateralConfig(
+        uint8 id
+    ) external view returns (DataTypes.CollateralConfig memory) {
+        return
+            DataTypes.CollateralConfig({
+                ltv: _eModeCategories[id].ltv,
+                liquidationThreshold: _eModeCategories[id].liquidationThreshold,
+                liquidationBonus: _eModeCategories[id].liquidationBonus
+            });
+    }
+
+    /// @inheritdoc IPool
+    function getEModeCategoryLabel(
+        uint8 id
+    ) external view returns (string memory) {
+        return _eModeCategories[id].label;
+    }
+
+    /// @inheritdoc IPool
+    function getEModeCategoryCollateralBitmap(
+        uint8 id
+    ) external view returns (uint128) {
+        return _eModeCategories[id].collateralBitmap;
+    }
+
+    /// @inheritdoc IPool
+    function getEModeCategoryBorrowableBitmap(
+        uint8 id
+    ) external view returns (uint128) {
+        return _eModeCategories[id].borrowableBitmap;
     }
 
     /// @inheritdoc IPool
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/PoolInstance.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/PoolInstance.sol
index 121d18a..31d76b6 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/PoolInstance.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/PoolInstance.sol
@@ -1,22 +1,16 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.0;
 
-import {Pool} from "../contracts/protocol/pool/Pool.sol";
-import {IPoolAddressesProvider} from "../contracts/interfaces/IPoolAddressesProvider.sol";
-import {Errors} from "../contracts/protocol/libraries/helpers/Errors.sol";
+import {PoolInstance} from "aave-v3-origin/contracts/instances/PoolInstance.sol";
+import {IPoolAddressesProvider, Errors} from "aave-v3-origin/contracts/protocol/pool/Pool.sol";
+import {CustomInitialize} from "./CustomInitialize.sol";
 
-contract PoolInstance is Pool {
-    uint256 public constant POOL_REVISION = 4;
+/**
+ * @notice Pool instance
+ */
+contract PoolInstance3_2 is PoolInstance {
+    constructor(IPoolAddressesProvider provider) PoolInstance(provider) {}
 
-    constructor(IPoolAddressesProvider provider) Pool(provider) {}
-
-    /**
-     * @notice Initializes the Pool.
-     * @dev Function is invoked by the proxy contract when the Pool contract is added to the
-     * PoolAddressesProvider of the market.
-     * @dev Caching the address of the PoolAddressesProvider in order to reduce gas consumption on subsequent operations
-     * @param provider The address of the PoolAddressesProvider
-     */
     function initialize(
         IPoolAddressesProvider provider
     ) external virtual override initializer {
@@ -24,10 +18,6 @@ contract PoolInstance is Pool {
             provider == ADDRESSES_PROVIDER,
             Errors.INVALID_ADDRESSES_PROVIDER
         );
-        _maxStableRateBorrowSizePercent = 0.25e4;
-    }
-
-    function getRevision() internal pure virtual override returns (uint256) {
-        return POOL_REVISION;
+        CustomInitialize.initialize(_reservesCount, _reservesList, _reserves);
     }
 }
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/PoolLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/PoolLogic.sol
index ec1cc3c..5dd80d3 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/PoolLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/PoolLogic.sol
@@ -46,7 +46,6 @@ library PoolLogic {
         require(Address.isContract(params.asset), Errors.NOT_CONTRACT);
         reservesData[params.asset].init(
             params.aTokenAddress,
-            params.stableDebtAddress,
             params.variableDebtAddress,
             params.interestRateStrategyAddress
         );
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/PoolStorage.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/PoolStorage.sol
index 4b03aa0..8db79fe 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/PoolStorage.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/PoolStorage.sol
@@ -43,8 +43,8 @@ contract PoolStorage {
     // FlashLoan premium paid to protocol treasury, expressed in bps
     uint128 internal _flashLoanPremiumToProtocol;
 
-    // Available liquidity that can be borrowed at once at stable rate, expressed in bps
-    uint64 internal _maxStableRateBorrowSizePercent;
+    // DEPRECATED on v3.2.0
+    uint64 internal __DEPRECATED_maxStableRateBorrowSizePercent;
 
     // Maximum number of active reserves there have been in the protocol. It is the upper bound of the reserves list
     uint16 internal _reservesCount;
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/ReserveConfiguration.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/ReserveConfiguration.sol
index 0a37b4b..fc8bcf4 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/ReserveConfiguration.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/ReserveConfiguration.sol
@@ -17,7 +17,6 @@ library ReserveConfiguration {
     uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore
-    uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore
@@ -26,7 +25,7 @@ library ReserveConfiguration {
     uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-    uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    //@notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
     uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant VIRTUAL_ACC_ACTIVE_MASK =        0xEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
@@ -38,7 +37,6 @@ library ReserveConfiguration {
     uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;
     uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;
     uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;
-    uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;
     uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;
     uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;
     uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;
@@ -47,7 +45,7 @@ library ReserveConfiguration {
     uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;
     uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;
     uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;
-    uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;
+    //@notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
     uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;
     uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;
     uint256 internal constant VIRTUAL_ACC_START_BIT_POSITION = 252;
@@ -60,7 +58,6 @@ library ReserveConfiguration {
     uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;
     uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;
     uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;
-    uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;
     uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;
     uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;
 
@@ -342,32 +339,6 @@ library ReserveConfiguration {
         return (self.data & ~BORROWING_MASK) != 0;
     }
 
-    /**
-     * @notice Enables or disables stable rate borrowing on the reserve
-     * @param self The reserve configuration
-     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise
-     */
-    function setStableRateBorrowingEnabled(
-        DataTypes.ReserveConfigurationMap memory self,
-        bool enabled
-    ) internal pure {
-        self.data =
-            (self.data & STABLE_BORROWING_MASK) |
-            (uint256(enabled ? 1 : 0) <<
-                STABLE_BORROWING_ENABLED_START_BIT_POSITION);
-    }
-
-    /**
-     * @notice Gets the stable rate borrowing state of the reserve
-     * @param self The reserve configuration
-     * @return The stable rate borrowing state
-     */
-    function getStableRateBorrowingEnabled(
-        DataTypes.ReserveConfigurationMap memory self
-    ) internal pure returns (bool) {
-        return (self.data & ~STABLE_BORROWING_MASK) != 0;
-    }
-
     /**
      * @notice Sets the reserve factor of the reserve
      * @param self The reserve configuration
@@ -547,38 +518,6 @@ library ReserveConfiguration {
             UNBACKED_MINT_CAP_START_BIT_POSITION;
     }
 
-    /**
-     * @notice Sets the eMode asset category
-     * @param self The reserve configuration
-     * @param category The asset category when the user selects the eMode
-     */
-    function setEModeCategory(
-        DataTypes.ReserveConfigurationMap memory self,
-        uint256 category
-    ) internal pure {
-        require(
-            category <= MAX_VALID_EMODE_CATEGORY,
-            Errors.INVALID_EMODE_CATEGORY
-        );
-
-        self.data =
-            (self.data & EMODE_CATEGORY_MASK) |
-            (category << EMODE_CATEGORY_START_BIT_POSITION);
-    }
-
-    /**
-     * @dev Gets the eMode asset category
-     * @param self The reserve configuration
-     * @return The eMode category for the asset
-     */
-    function getEModeCategory(
-        DataTypes.ReserveConfigurationMap memory self
-    ) internal pure returns (uint256) {
-        return
-            (self.data & ~EMODE_CATEGORY_MASK) >>
-            EMODE_CATEGORY_START_BIT_POSITION;
-    }
-
     /**
      * @notice Sets the flashloanable flag for the reserve
      * @param self The reserve configuration
@@ -638,19 +577,17 @@ library ReserveConfiguration {
      * @return The state flag representing active
      * @return The state flag representing frozen
      * @return The state flag representing borrowing enabled
-     * @return The state flag representing stableRateBorrowing enabled
      * @return The state flag representing paused
      */
     function getFlags(
         DataTypes.ReserveConfigurationMap memory self
-    ) internal pure returns (bool, bool, bool, bool, bool) {
+    ) internal pure returns (bool, bool, bool, bool) {
         uint256 dataLocal = self.data;
 
         return (
             (dataLocal & ~ACTIVE_MASK) != 0,
             (dataLocal & ~FROZEN_MASK) != 0,
             (dataLocal & ~BORROWING_MASK) != 0,
-            (dataLocal & ~STABLE_BORROWING_MASK) != 0,
             (dataLocal & ~PAUSED_MASK) != 0
         );
     }
@@ -663,15 +600,10 @@ library ReserveConfiguration {
      * @return The state param representing liquidation bonus
      * @return The state param representing reserve decimals
      * @return The state param representing reserve factor
-     * @return The state param representing eMode category
      */
     function getParams(
         DataTypes.ReserveConfigurationMap memory self
-    )
-        internal
-        pure
-        returns (uint256, uint256, uint256, uint256, uint256, uint256)
-    {
+    ) internal pure returns (uint256, uint256, uint256, uint256, uint256) {
         uint256 dataLocal = self.data;
 
         return (
@@ -682,9 +614,7 @@ library ReserveConfiguration {
                 LIQUIDATION_BONUS_START_BIT_POSITION,
             (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,
             (dataLocal & ~RESERVE_FACTOR_MASK) >>
-                RESERVE_FACTOR_START_BIT_POSITION,
-            (dataLocal & ~EMODE_CATEGORY_MASK) >>
-                EMODE_CATEGORY_START_BIT_POSITION
+                RESERVE_FACTOR_START_BIT_POSITION
         );
     }
 
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/ReserveLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/ReserveLogic.sol
index f6215e2..54e3c0e 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/ReserveLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/ReserveLogic.sol
@@ -3,7 +3,6 @@ pragma solidity ^0.8.10;
 
 import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
 import {GPv2SafeERC20} from "../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
-import {IStableDebtToken} from "../../../interfaces/IStableDebtToken.sol";
 import {IVariableDebtToken} from "../../../interfaces/IVariableDebtToken.sol";
 import {IReserveInterestRateStrategy} from "../../../interfaces/IReserveInterestRateStrategy.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
@@ -138,14 +137,12 @@ library ReserveLogic {
      * @notice Initializes a reserve.
      * @param reserve The reserve object
      * @param aTokenAddress The address of the overlying atoken contract
-     * @param stableDebtTokenAddress The address of the overlying stable debt token contract
      * @param variableDebtTokenAddress The address of the overlying variable debt token contract
      * @param interestRateStrategyAddress The address of the interest rate strategy contract
      */
     function init(
         DataTypes.ReserveData storage reserve,
         address aTokenAddress,
-        address stableDebtTokenAddress,
         address variableDebtTokenAddress,
         address interestRateStrategyAddress
     ) internal {
@@ -157,20 +154,12 @@ library ReserveLogic {
         reserve.liquidityIndex = uint128(WadRayMath.RAY);
         reserve.variableBorrowIndex = uint128(WadRayMath.RAY);
         reserve.aTokenAddress = aTokenAddress;
-        reserve.stableDebtTokenAddress = stableDebtTokenAddress;
         reserve.variableDebtTokenAddress = variableDebtTokenAddress;
         reserve.interestRateStrategyAddress = interestRateStrategyAddress;
     }
 
-    struct UpdateInterestRatesAndVirtualBalanceLocalVars {
-        uint256 nextLiquidityRate;
-        uint256 nextStableRate;
-        uint256 nextVariableRate;
-        uint256 totalVariableDebt;
-    }
-
     /**
-     * @notice Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate.
+     * @notice Updates the reserve current variable borrow rate and the current liquidity rate.
      * @param reserve The reserve reserve to be updated
      * @param reserveCache The caching layer for the reserve data
      * @param reserveAddress The address of the reserve to be updated
@@ -184,38 +173,32 @@ library ReserveLogic {
         uint256 liquidityAdded,
         uint256 liquidityTaken
     ) internal {
-        UpdateInterestRatesAndVirtualBalanceLocalVars memory vars;
-
-        vars.totalVariableDebt = reserveCache.nextScaledVariableDebt.rayMul(
+        uint256 totalVariableDebt = reserveCache.nextScaledVariableDebt.rayMul(
             reserveCache.nextVariableBorrowIndex
         );
 
         (
-            vars.nextLiquidityRate,
-            vars.nextStableRate,
-            vars.nextVariableRate
+            uint256 nextLiquidityRate,
+            uint256 nextVariableRate
         ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
-            .calculateInterestRates(
-                DataTypes.CalculateInterestRatesParams({
-                    unbacked: reserve.unbacked,
-                    liquidityAdded: liquidityAdded,
-                    liquidityTaken: liquidityTaken,
-                    totalStableDebt: reserveCache.nextTotalStableDebt,
-                    totalVariableDebt: vars.totalVariableDebt,
-                    averageStableBorrowRate: reserveCache
-                        .nextAvgStableBorrowRate,
-                    reserveFactor: reserveCache.reserveFactor,
-                    reserve: reserveAddress,
-                    usingVirtualBalance: reserve
-                        .configuration
-                        .getIsVirtualAccActive(),
-                    virtualUnderlyingBalance: reserve.virtualUnderlyingBalance
-                })
-            );
+                .calculateInterestRates(
+                    DataTypes.CalculateInterestRatesParams({
+                        unbacked: reserve.unbacked,
+                        liquidityAdded: liquidityAdded,
+                        liquidityTaken: liquidityTaken,
+                        totalDebt: totalVariableDebt,
+                        reserveFactor: reserveCache.reserveFactor,
+                        reserve: reserveAddress,
+                        usingVirtualBalance: reserve
+                            .configuration
+                            .getIsVirtualAccActive(),
+                        virtualUnderlyingBalance: reserve
+                            .virtualUnderlyingBalance
+                    })
+                );
 
-        reserve.currentLiquidityRate = vars.nextLiquidityRate.toUint128();
-        reserve.currentStableBorrowRate = vars.nextStableRate.toUint128();
-        reserve.currentVariableBorrowRate = vars.nextVariableRate.toUint128();
+        reserve.currentLiquidityRate = nextLiquidityRate.toUint128();
+        reserve.currentVariableBorrowRate = nextVariableRate.toUint128();
 
         // Only affect virtual balance if the reserve uses it
         if (reserve.configuration.getIsVirtualAccActive()) {
@@ -229,23 +212,14 @@ library ReserveLogic {
 
         emit ReserveDataUpdated(
             reserveAddress,
-            vars.nextLiquidityRate,
-            vars.nextStableRate,
-            vars.nextVariableRate,
+            nextLiquidityRate,
+            0,
+            nextVariableRate,
             reserveCache.nextLiquidityIndex,
             reserveCache.nextVariableBorrowIndex
         );
     }
 
-    struct AccrueToTreasuryLocalVars {
-        uint256 prevTotalStableDebt;
-        uint256 prevTotalVariableDebt;
-        uint256 currTotalVariableDebt;
-        uint256 cumulatedStableInterest;
-        uint256 totalDebtAccrued;
-        uint256 amountToMint;
-    }
-
     /**
      * @notice Mints part of the repaid interest to the reserve treasury as a function of the reserve factor for the
      * specific asset.
@@ -256,47 +230,30 @@ library ReserveLogic {
         DataTypes.ReserveData storage reserve,
         DataTypes.ReserveCache memory reserveCache
     ) internal {
-        AccrueToTreasuryLocalVars memory vars;
-
         if (reserveCache.reserveFactor == 0) {
             return;
         }
 
         //calculate the total variable debt at moment of the last interaction
-        vars.prevTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(
-            reserveCache.currVariableBorrowIndex
-        );
+        uint256 prevTotalVariableDebt = reserveCache
+            .currScaledVariableDebt
+            .rayMul(reserveCache.currVariableBorrowIndex);
 
         //calculate the new total variable debt after accumulation of the interest on the index
-        vars.currTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(
-            reserveCache.nextVariableBorrowIndex
-        );
-
-        //calculate the stable debt until the last timestamp update
-        vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(
-            reserveCache.currAvgStableBorrowRate,
-            reserveCache.stableDebtLastUpdateTimestamp,
-            reserveCache.reserveLastUpdateTimestamp
-        );
-
-        vars.prevTotalStableDebt = reserveCache.currPrincipalStableDebt.rayMul(
-            vars.cumulatedStableInterest
-        );
+        uint256 currTotalVariableDebt = reserveCache
+            .currScaledVariableDebt
+            .rayMul(reserveCache.nextVariableBorrowIndex);
 
         //debt accrued is the sum of the current debt minus the sum of the debt at the last update
-        vars.totalDebtAccrued =
-            vars.currTotalVariableDebt +
-            reserveCache.currTotalStableDebt -
-            vars.prevTotalVariableDebt -
-            vars.prevTotalStableDebt;
+        uint256 totalDebtAccrued = currTotalVariableDebt -
+            prevTotalVariableDebt;
 
-        vars.amountToMint = vars.totalDebtAccrued.percentMul(
+        uint256 amountToMint = totalDebtAccrued.percentMul(
             reserveCache.reserveFactor
         );
 
-        if (vars.amountToMint != 0) {
-            reserve.accruedToTreasury += vars
-                .amountToMint
+        if (amountToMint != 0) {
+            reserve.accruedToTreasury += amountToMint
                 .rayDiv(reserveCache.nextLiquidityIndex)
                 .toUint128();
         }
@@ -370,7 +327,6 @@ library ReserveLogic {
         reserveCache.currVariableBorrowRate = reserve.currentVariableBorrowRate;
 
         reserveCache.aTokenAddress = reserve.aTokenAddress;
-        reserveCache.stableDebtTokenAddress = reserve.stableDebtTokenAddress;
         reserveCache.variableDebtTokenAddress = reserve
             .variableDebtTokenAddress;
 
@@ -381,20 +337,6 @@ library ReserveLogic {
             reserveCache.variableDebtTokenAddress
         ).scaledTotalSupply();
 
-        (
-            reserveCache.currPrincipalStableDebt,
-            reserveCache.currTotalStableDebt,
-            reserveCache.currAvgStableBorrowRate,
-            reserveCache.stableDebtLastUpdateTimestamp
-        ) = IStableDebtToken(reserveCache.stableDebtTokenAddress)
-            .getSupplyData();
-
-        // by default the actions are considered as not affecting the debt balances.
-        // if the action involves mint/burn of debt, the cache needs to be updated
-        reserveCache.nextTotalStableDebt = reserveCache.currTotalStableDebt;
-        reserveCache.nextAvgStableBorrowRate = reserveCache
-            .currAvgStableBorrowRate;
-
         return reserveCache;
     }
 }
diff --git a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/ValidationLogic.sol b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/ValidationLogic.sol
index 2437438..64aa0db 100644
--- a/tmp/324_0xEe8EBB0704F5954Ab281166f35309087E1b81903_flat/ValidationLogic.sol
+++ b/tmp/324_0x3Db69F17e682a8E6f029a90c8DD04A4689B988b9_flat/ValidationLogic.sol
@@ -5,6 +5,7 @@ import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
 import {Address} from "../../../dependencies/openzeppelin/contracts/Address.sol";
 import {GPv2SafeERC20} from "../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
 import {IReserveInterestRateStrategy} from "../../../interfaces/IReserveInterestRateStrategy.sol";
+import {IScaledBalanceToken} from "../../../interfaces/IScaledBalanceToken.sol";
 import {IPriceOracleGetter} from "../../../interfaces/IPriceOracleGetter.sol";
 import {IAToken} from "../../../interfaces/IAToken.sol";
 import {IPriceOracleSentinel} from "../../../interfaces/IPriceOracleSentinel.sol";
@@ -12,6 +13,7 @@ import {IPoolAddressesProvider} from "../../../interfaces/IPoolAddressesProvider
 import {IAccessControl} from "../../../dependencies/openzeppelin/contracts/IAccessControl.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
 import {UserConfiguration} from "../configuration/UserConfiguration.sol";
+import {EModeConfiguration} from "../configuration/EModeConfiguration.sol";
 import {Errors} from "../helpers/Errors.sol";
 import {WadRayMath} from "../math/WadRayMath.sol";
 import {PercentageMath} from "../math/PercentageMath.sol";
@@ -70,7 +72,7 @@ library ValidationLogic {
     ) internal view {
         require(amount != 0, Errors.INVALID_AMOUNT);
 
-        (bool isActive, bool isFrozen, , , bool isPaused) = reserveCache
+        (bool isActive, bool isFrozen, , bool isPaused) = reserveCache
             .reserveConfiguration
             .getFlags();
         require(isActive, Errors.RESERVE_INACTIVE);
@@ -111,7 +113,7 @@ library ValidationLogic {
             Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE
         );
 
-        (bool isActive, , , , bool isPaused) = reserveCache
+        (bool isActive, , , bool isPaused) = reserveCache
             .reserveConfiguration
             .getFlags();
         require(isActive, Errors.RESERVE_INACTIVE);
@@ -131,13 +133,11 @@ library ValidationLogic {
         uint256 borrowCap;
         uint256 amountInBaseCurrency;
         uint256 assetUnit;
-        address eModePriceSource;
         address siloedBorrowingAddress;
         bool isActive;
         bool isFrozen;
         bool isPaused;
         bool borrowingEnabled;
-        bool stableRateBorrowingEnabled;
         bool siloedBorrowingEnabled;
     }
 
@@ -162,7 +162,6 @@ library ValidationLogic {
             vars.isActive,
             vars.isFrozen,
             vars.borrowingEnabled,
-            vars.stableRateBorrowingEnabled,
             vars.isPaused
         ) = params.reserveCache.reserveConfiguration.getFlags();
 
@@ -186,8 +185,7 @@ library ValidationLogic {
 
         //validate interest rate mode
         require(
-            params.interestRateMode == DataTypes.InterestRateMode.VARIABLE ||
-                params.interestRateMode == DataTypes.InterestRateMode.STABLE,
+            params.interestRateMode == DataTypes.InterestRateMode.VARIABLE,
             Errors.INVALID_INTEREST_RATE_MODE_SELECTED
         );
 
@@ -209,10 +207,7 @@ library ValidationLogic {
                 .currScaledVariableDebt
                 .rayMul(params.reserveCache.nextVariableBorrowIndex);
 
-            vars.totalDebt =
-                params.reserveCache.currTotalStableDebt +
-                vars.totalSupplyVariableDebt +
-                params.amount;
+            vars.totalDebt = vars.totalSupplyVariableDebt + params.amount;
 
             unchecked {
                 require(
@@ -248,12 +243,12 @@ library ValidationLogic {
 
         if (params.userEModeCategory != 0) {
             require(
-                params.reserveCache.reserveConfiguration.getEModeCategory() ==
-                    params.userEModeCategory,
-                Errors.INCONSISTENT_EMODE_CATEGORY
+                EModeConfiguration.isReserveEnabledOnBitmap(
+                    eModeCategories[params.userEModeCategory].borrowableBitmap,
+                    reservesData[params.asset].id
+                ),
+                Errors.NOT_BORROWABLE_IN_EMODE
             );
-            vars.eModePriceSource = eModeCategories[params.userEModeCategory]
-                .priceSource;
         }
 
         (
@@ -288,11 +283,7 @@ library ValidationLogic {
         );
 
         vars.amountInBaseCurrency =
-            IPriceOracleGetter(params.oracle).getAssetPrice(
-                vars.eModePriceSource != address(0)
-                    ? vars.eModePriceSource
-                    : params.asset
-            ) *
+            IPriceOracleGetter(params.oracle).getAssetPrice(params.asset) *
             params.amount;
         unchecked {
             vars.amountInBaseCurrency /= vars.assetUnit;
@@ -308,49 +299,6 @@ library ValidationLogic {
             Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW
         );
 
-        /**
-         * Following conditions need to be met if the user is borrowing at a stable rate:
-         * 1. Reserve must be enabled for stable rate borrowing
-         * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency
-         *    they are borrowing, to prevent abuses.
-         * 3. Users will be able to borrow only a portion of the total available liquidity
-         */
-
-        if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {
-            //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve
-
-            require(
-                vars.stableRateBorrowingEnabled,
-                Errors.STABLE_BORROWING_NOT_ENABLED
-            );
-
-            require(
-                !params.userConfig.isUsingAsCollateral(
-                    reservesData[params.asset].id
-                ) ||
-                    params.reserveCache.reserveConfiguration.getLtv() == 0 ||
-                    params.amount >
-                    IERC20(params.reserveCache.aTokenAddress).balanceOf(
-                        params.userAddress
-                    ),
-                Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY
-            );
-
-            vars.availableLiquidity = reservesData[params.asset]
-                .virtualUnderlyingBalance;
-
-            //calculate the max available loan size in stable rate mode as a percentage of the
-            //available liquidity
-            uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(
-                params.maxStableLoanPercent
-            );
-
-            require(
-                params.amount <= maxLoanSizeStable,
-                Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE
-            );
-        }
-
         if (params.userConfig.isBorrowingAny()) {
             (vars.siloedBorrowingEnabled, vars.siloedBorrowingAddress) = params
                 .userConfig
@@ -377,145 +325,33 @@ library ValidationLogic {
      * @notice Validates a repay action.
      * @param reserveCache The cached data of the reserve
      * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)
-     * @param interestRateMode The interest rate mode of the debt being repaid
      * @param onBehalfOf The address of the user msg.sender is repaying for
-     * @param stableDebt The borrow balance of the user
-     * @param variableDebt The borrow balance of the user
+     * @param debt The borrow balance of the user
      */
     function validateRepay(
         DataTypes.ReserveCache memory reserveCache,
         uint256 amountSent,
         DataTypes.InterestRateMode interestRateMode,
         address onBehalfOf,
-        uint256 stableDebt,
-        uint256 variableDebt
+        uint256 debt
     ) internal view {
         require(amountSent != 0, Errors.INVALID_AMOUNT);
         require(
-            amountSent != type(uint256).max || msg.sender == onBehalfOf,
-            Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF
+            interestRateMode == DataTypes.InterestRateMode.VARIABLE,
+            Errors.INVALID_INTEREST_RATE_MODE_SELECTED
         );
-
-        (bool isActive, , , , bool isPaused) = reserveCache
-            .reserveConfiguration
-            .getFlags();
-        require(isActive, Errors.RESERVE_INACTIVE);
-        require(!isPaused, Errors.RESERVE_PAUSED);
-
         require(
-            (stableDebt != 0 &&
-                interestRateMode == DataTypes.InterestRateMode.STABLE) ||
-                (variableDebt != 0 &&
-                    interestRateMode == DataTypes.InterestRateMode.VARIABLE),
-            Errors.NO_DEBT_OF_SELECTED_TYPE
+            amountSent != type(uint256).max || msg.sender == onBehalfOf,
+            Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF
         );
-    }
-
-    /**
-     * @notice Validates a swap of borrow rate mode.
-     * @param reserve The reserve state on which the user is swapping the rate
-     * @param reserveCache The cached data of the reserve
-     * @param userConfig The user reserves configuration
-     * @param stableDebt The stable debt of the user
-     * @param variableDebt The variable debt of the user
-     * @param currentRateMode The rate mode of the debt being swapped
-     */
-    function validateSwapRateMode(
-        DataTypes.ReserveData storage reserve,
-        DataTypes.ReserveCache memory reserveCache,
-        DataTypes.UserConfigurationMap storage userConfig,
-        uint256 stableDebt,
-        uint256 variableDebt,
-        DataTypes.InterestRateMode currentRateMode
-    ) internal view {
-        (
-            bool isActive,
-            ,
-            ,
-            bool stableRateEnabled,
-            bool isPaused
-        ) = reserveCache.reserveConfiguration.getFlags();
-        require(isActive, Errors.RESERVE_INACTIVE);
-        require(!isPaused, Errors.RESERVE_PAUSED);
 
-        if (currentRateMode == DataTypes.InterestRateMode.STABLE) {
-            require(stableDebt != 0, Errors.NO_OUTSTANDING_STABLE_DEBT);
-        } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {
-            require(variableDebt != 0, Errors.NO_OUTSTANDING_VARIABLE_DEBT);
-            /**
-             * user wants to swap to stable, before swapping we need to ensure that
-             * 1. stable borrow rate is enabled on the reserve
-             * 2. user is not trying to abuse the reserve by supplying
-             * more collateral than he is borrowing, artificially lowering
-             * the interest rate, borrowing at variable, and switching to stable
-             */
-            require(stableRateEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);
-
-            require(
-                !userConfig.isUsingAsCollateral(reserve.id) ||
-                    reserveCache.reserveConfiguration.getLtv() == 0 ||
-                    stableDebt + variableDebt >
-                    IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender),
-                Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY
-            );
-        } else {
-            revert(Errors.INVALID_INTEREST_RATE_MODE_SELECTED);
-        }
-    }
-
-    /**
-     * @notice Validates a stable borrow rate rebalance action.
-     * @dev Rebalancing is accepted when depositors are earning <= 90% of their earnings in pure supply/demand market (variable rate only)
-     * For this to be the case, there has to be quite large stable debt with an interest rate below the current variable rate.
-     * @param reserve The reserve state on which the user is getting rebalanced
-     * @param reserveCache The cached state of the reserve
-     * @param reserveAddress The address of the reserve
-     */
-    function validateRebalanceStableBorrowRate(
-        DataTypes.ReserveData storage reserve,
-        DataTypes.ReserveCache memory reserveCache,
-        address reserveAddress
-    ) internal view {
-        (bool isActive, , , , bool isPaused) = reserveCache
+        (bool isActive, , , bool isPaused) = reserveCache
             .reserveConfiguration
             .getFlags();
         require(isActive, Errors.RESERVE_INACTIVE);
         require(!isPaused, Errors.RESERVE_PAUSED);
 
-        uint256 totalDebt = IERC20(reserveCache.stableDebtTokenAddress)
-            .totalSupply() +
-            IERC20(reserveCache.variableDebtTokenAddress).totalSupply();
-
-        (
-            uint256 liquidityRateVariableDebtOnly,
-            ,
-
-        ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
-                .calculateInterestRates(
-                    DataTypes.CalculateInterestRatesParams({
-                        unbacked: reserve.unbacked,
-                        liquidityAdded: 0,
-                        liquidityTaken: 0,
-                        totalStableDebt: 0,
-                        totalVariableDebt: totalDebt,
-                        averageStableBorrowRate: 0,
-                        reserveFactor: reserveCache.reserveFactor,
-                        reserve: reserveAddress,
-                        usingVirtualBalance: reserve
-                            .configuration
-                            .getIsVirtualAccActive(),
-                        virtualUnderlyingBalance: reserve
-                            .virtualUnderlyingBalance
-                    })
-                );
-
-        require(
-            reserveCache.currLiquidityRate <=
-                liquidityRateVariableDebtOnly.percentMul(
-                    REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD
-                ),
-            Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET
-        );
+        require(debt != 0, Errors.NO_DEBT_OF_SELECTED_TYPE);
     }
 
     /**
@@ -529,7 +365,7 @@ library ValidationLogic {
     ) internal pure {
         require(userBalance != 0, Errors.UNDERLYING_BALANCE_ZERO);
 
-        (bool isActive, , , , bool isPaused) = reserveCache
+        (bool isActive, , , bool isPaused) = reserveCache
             .reserveConfiguration
             .getFlags();
         require(isActive, Errors.RESERVE_INACTIVE);
@@ -609,17 +445,13 @@ library ValidationLogic {
             vars.collateralReserveActive,
             ,
             ,
-            ,
             vars.collateralReservePaused
         ) = collateralReserve.configuration.getFlags();
 
-        (
-            vars.principalReserveActive,
-            ,
-            ,
-            ,
-            vars.principalReservePaused
-        ) = params.debtReserveCache.reserveConfiguration.getFlags();
+        (vars.principalReserveActive, , , vars.principalReservePaused) = params
+            .debtReserveCache
+            .reserveConfiguration
+            .getFlags();
 
         require(
             vars.collateralReserveActive && vars.principalReserveActive,
@@ -778,10 +610,6 @@ library ValidationLogic {
             reserve.id != 0 || reservesList[0] == asset,
             Errors.ASSET_NOT_LISTED
         );
-        require(
-            IERC20(reserve.stableDebtTokenAddress).totalSupply() == 0,
-            Errors.STABLE_DEBT_NOT_ZERO
-        );
         require(
             IERC20(reserve.variableDebtTokenAddress).totalSupply() == 0,
             Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO
@@ -795,25 +623,23 @@ library ValidationLogic {
 
     /**
      * @notice Validates the action of setting efficiency mode.
-     * @param reservesData The state of all the reserves
-     * @param reservesList The addresses of all the active reserves
      * @param eModeCategories a mapping storing configurations for all efficiency mode categories
      * @param userConfig the user configuration
      * @param reservesCount The total number of valid reserves
      * @param categoryId The id of the category
      */
     function validateSetUserEMode(
-        mapping(address => DataTypes.ReserveData) storage reservesData,
-        mapping(uint256 => address) storage reservesList,
         mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
         DataTypes.UserConfigurationMap memory userConfig,
         uint256 reservesCount,
         uint8 categoryId
     ) internal view {
+        DataTypes.EModeCategory storage eModeCategory = eModeCategories[
+            categoryId
+        ];
         // category is invalid if the liq threshold is not set
         require(
-            categoryId == 0 ||
-                eModeCategories[categoryId].liquidationThreshold != 0,
+            categoryId == 0 || eModeCategory.liquidationThreshold != 0,
             Errors.INCONSISTENT_EMODE_CATEGORY
         );
 
@@ -828,12 +654,12 @@ library ValidationLogic {
             unchecked {
                 for (uint256 i = 0; i < reservesCount; i++) {
                     if (userConfig.isBorrowing(i)) {
-                        DataTypes.ReserveConfigurationMap
-                            memory configuration = reservesData[reservesList[i]]
-                                .configuration;
                         require(
-                            configuration.getEModeCategory() == categoryId,
-                            Errors.INCONSISTENT_EMODE_CATEGORY
+                            EModeConfiguration.isReserveEnabledOnBitmap(
+                                eModeCategory.borrowableBitmap,
+                                i
+                            ),
+                            Errors.NOT_BORROWABLE_IN_EMODE
                         );
                     }
                 }
